---
title: "Routing"
pre: "4. "
weight: 40
date: 2018-08-24T10:53:26-05:00
---

A second major item to consider with dynamic web servers is how to respond to incoming requests.  With static web servers, it is pretty simple - we map the virtual path supplied by the URL to a file path on the file server.  But the URL supplied in a request _doesn't_ have to correspond to any real object on the server - we can create any object we want, and send it back.

Consider the case of [Placeholder.com](https://placeholder.com/), a service that offers image URLs you can use in a site layout to simulate images.  For example, the image below is generated by the site by using the URL By using the URL `//via.placeholder.com/350x150`:

![350 x 150 pixel placeholder image](//via.placeholder.com/350x150)

Does Placeholder.com have thousands of images of varying sizes stored on a disk somewhere?  No!  It generates the image data _dynamically_ based on the request - here it reads the `350x150` and uses it to determine the size of the image needed.  It also reads other aspects of the URL and uses those to set other aspects, i.e. the url `//via.placeholder.com/350x150/C497FF/FFFFFF?text=Hello` generates the image:

![Another placeholder image with custom color and text](//via.placeholder.com/350x150/C497FF/FFFFFF?text=Hello) 

Clearly, we're conveying information to the Placeholder.com server _through the url_.  This is much like passing parameters to a function - it is how we communicate what we want the server to do with our request!

## The URL, Revisited

Now that we're thinking of the URL as a tool for passing information to the server, let's reexamine its parts:

![A diagram of a URL]({{<static "images/6.3.1.png">}})

The **protocol** is the protocol used for communication, and the **host** is the domain or IP address of the server.  Note that these are _not_ included in Node's `req.url` parameter, as these are used to find the right server and talk to it using the right protocol - by the time your Node server is generating the `req` object, the request has already found your server and is communicating with the protocol.  

This is also why when we've been parsing `req.url` with the [URL]() object, we've supplied a host and protocol of `http://localhost`:

```js
var url = new URL(req.url, "http://localhost");
```

This gives the URL object a placeholder for the missing protocol and host, so that it can parse the supplied URL without error.  Just keep in mind that by doing so the `url.protocol` and `url.host` properties of `url` equal this "fake" host and protocol.

The **path** is the path to the virtual resource requested, accessible in our parsed URL as `url.pathname`.  Traditionally, this corresponded to a file path, which is how we used it in our fileserver examples.  But as we have seen with Placeholder.com, it can also be used to convey other information - in that case, the size of the image, its background color, and foreground color.

The **query** or **querystring** is a list of key-value pairs, proceeded by the `?`.  Traditionally this would be used to modify some aspect of the request, such as requesting a particular data format or portion of a dataset.  It is also how forms are submitted with a GET request - the form data is encoded into the query string.

The **hash** or **fragment** is proceeded by a `#`, and traditionally indicates an element on the page that the browser should auto-scroll to.  This element should have an `id` attribute that matches the one supplied by the hash.  For example, clicking this link: [#the-url-revisited](#the-url-revisited) will scroll back to the header for this section (note we left the path blank, so the browser assumes we want to stay on this page).

Clearly our URL can clearly convey a lot of data to our server. But that's not the only information that we can use in deciding how to respond to a request.

## Request Method, Revisited

In addition, we also receive the HTTP Method used for the request, i.e. GET, POST, PATCH, PUT, or DELETE. These again map back to the traditional role of a web server as a file server - GET retrieves a resource, POST uploads one, PATCH and PUT modify one, and DELETE removes it. But we can also create, read, update, and destroy _virtual_ resources, i.e. resources generated and stored on the server that are _not_ files.  We'll talk more about this when we discuss persistent storage.

## Headers, Revisited 

We can also convey additional information for the server to consider as part of the request headers.  This is usually used to convey information tangental to the request, like authentication and cookies.  We'll also discuss this a bit further on.

## Routing

The process of mapping the incoming request to the appropriate response is called _routing_.  Consider how we did this with our simple fileserver:

```js
/** @function handleRequest
 * Provides a function for handling HTTP requests 
 * @param {http.incomingMessage} req - the request object
 * @param {http.serverResponse} res - the response object
 */
function handleRequest(req, res) {
  if(req.method !== 'GET') return res.writeHead(501).end();
  var pathname = new URL(req.url, 'http://localhost').pathname;    
  fs.stat(path.join("public", pathname), (err, stat) => {
    if(err) return res.writeHead(404).end();
    if(stat.isFile()) return serveFile(req, res);
    if(stat.isDirectory()) return listDirectory(req, res);
    return res.writeHead(404).end();
  });
}
```

We used a series of `if` statements to map the request to the function that would generate a response - _serveFile()_ or _listDirectory()_.  In fact, we can think of all requests as a **request => function** mapping, and the pair as a route.  Let's consider a more involved website with several dynamically generated pages - _home_, _about_, and _stuff_.  We could create a number of functions to generate and serve these pages - `serveHome()`, `serveAbout()`, and `serveStuff()`, which should be mapped to `/`, `/about`, and `/stuff`:

We could write this route as a route table (a kind of shorthand):

```
'/'             => serveHome
'/

However, we need to consider _more_ than just the URL
