<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Routing :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/index.html</link><description>Are we there yet?</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 06 Mar 2025 15:49:16 -0600</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis526/08-routing/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/01-introduction/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/01-introduction/index.html</guid><description>Once again, we’ll return to the request-response pattern diagram.
We revisit this diagram because it is so central to how HTTP servers work. At the heart, a server’s primary responsibility is to respond to an incoming request. Thus, in writing a web server, our primary task is to determine what to respond with. With static web servers, the answer is pretty simple - we map the virtual path supplied by the URL to a file path on the file server. But the URL supplied in a request doesn’t have to correspond to any real object on the server - we can create any object we want, and send it back.</description></item><item><title>Request Routing</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/02-routing/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/02-routing/index.html</guid><description>In web development, routing refers to the process of matching an incoming request with generating the appropriate response. For most web servers (and definitely for Node-based ones), we abstract the process of generating the response into a function. We often call these functions endpoints as their purpose is to serve the response, effectively ending the processing of an incoming request with an appropriate response.
With a Node webserver, endpoint functions typically take in a req (an instance of http.IncomingMessage) and res (an instance of http.ServerResponse) objects. These objects form an abstraction around the HTTP request and response.</description></item><item><title>Resources</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/03-resources/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/03-resources/index.html</guid><description>As the web transitioned to dynamic pages, the concept of the URL path evolved. With a static server, the path indicates an actual file that exists on the fileserver. But with dynamic pages, the url doesn’t have to correspond to anything real. Consider the case of Placeholder.com, a service that offers image URLs you can use in a site layout to simulate images. For example, the image below is generated by the site by using the URL By using the URL //via.placeholder.com/350x150:</description></item><item><title>Request Revisted</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/04-request-revisited/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/04-request-revisited/index.html</guid><description>We’ve seen then how the request conveys information useful to selecting the appropriate endpoint with the path, and also the query string. But there is more information available in our request than just those two tidbits. And we have all of that information available to us for determining the correct response to send. With that in mind, let’s revisit the parts of the request in terms of what kinds of information they can convey.</description></item><item><title>REST</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/05-rest/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/05-rest/index.html</guid><description>We’ve already seen that with our blog, we could convey which post to display with different URL strategies, i.e.:
http://my-blog.com/posts?id=5 http://my-blog.com/posts/5 http://my-blog.com/posts/5-a-night-that-was-dark And that is just to display posts. What about when we want our blog software to allow the writer to submit new posts? Or edit existing ones? That’s a lot of different URLS we’ll need to keep track of.
Representational State Transfer (REST) Roy Fielding tackled this issue in Chapter 5 of his Ph.D. dissertation “Architectural Styles and the Design of Network-based Software Architectures.” He recognized that increasingly dynamic web servers were dealing with resources that could be created, updated, read, and destroyed, much like the resources in database systems (not surprisingly, many of these resources were persistently stored in such a database system). These operations are so pervasive in database systems that we have an acronym for them: CRUD.</description></item><item><title>Routers</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/06-routers/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/06-routers/index.html</guid><description>Many web development frameworks built upon this concept of routes by supplying a router, and object that would store route patterns and perform the routing operation. One popular Node library express, is at its heart a router. If we were to write our Node blog using Express, the syntax to create our routes would be:
const express = require('express'); var app = express(); // Home page app.get('/', serveHome); // Posts app.get('posts/', servePosts); app.get('posts/:id', servePost); app.post('posts/', createPost); app.post('posts/:id', updatePost); app.delete('posts/:id', deletePost); // Comments app.get('posts/:post_id/comments', servePosts); app.get('posts/:post_id/comments/:id', servePost); app.post('posts/:post_id/comments', createPost); app.post('posts/:post_id/comments/:id', updatePost); app.delete('posts/:post_id/comments/:id', deletePost); module.exports = app; The app variable is an instance of the express Application class, which itself is a wrapper around Node’s http.Server class. The Express Application adds (among other features), routing using the route methods app.get(), app.post(), app.put(), and app.delete(). These take routes either in string or regular expression form, and the wildcard values are assigned to an object in req.params. For example, we might write our servePost() method as:</description></item><item><title>APIs</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/07-apis/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/07-apis/index.html</guid><description>Before we step away from routing, we should take the time to discuss a specific style of web application that goes hand-in-hand with routing - an Application Programming Interface (API). An API is simply a interface for two programs to communicate, to allow one to act as a service for the other. Web APIs are APIs that use hyper-text transfer protocol (http) as the mechanism for this communication. Thus, the client program makes HTTP requests against the API server and receives responses. The Placeholder.com we discussed earlier in this chapter is an example of a web API - one that generates and serves placeholder images.</description></item><item><title>Web Hooks</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/08-web-hooks/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/08-web-hooks/index.html</guid><description>A lighter-weight alternative to a full-fledged API is a webhook. A webhook is simply an address a web application is instructed to make a HTTP request against when a specific event happens. For example, you can set your GitHub repository to trigger a webhook when a new commit is made to it. You simply provide the URL it should send a request to, and it will send a request with a payload (based on the event).</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis526/08-routing/09-summary/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/08-routing/09-summary/index.html</guid><description>In this chapter, we exported the idea of routes, a mechanism for mapping a request to the appropriate endpoint function to generate a response. Routes typically consist of both the request URL and the request method. RESTful routes provide a common strategy for implementing CRUD methods for a server-generated resource; any programmer familiar with REST will quickly be able to suss out the appropriate route.
We also explored routers are objects that make routing more manageable to implement. These allow you to define a route and tie it to an endpoint function used to generate the result. Most will also capture wildcards in the route, and supply those to the endpoint function in some form. We briefly looked at the Express framework, a Node framework that adds a router to the vanilla Node http.Server class.</description></item></channel></rss>