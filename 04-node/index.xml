<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction to Node :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/index.html</link><description>JavaScript on the Server</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 27 Jun 2024 14:51:29 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis526/04-node/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/01-introduction/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/01-introduction/index.html</guid><description>Node is an open-source, cross-platform JavaScript runtime environment build on Google’s V8 engine. It was created by Ryan Dahl in 2009 to allow for server-side scripting in JavaScript.
ECMAScript Support Node supports most of the features of ECMAScript 2015 (ES6), with the notable exception of ES6 modules (as Node adopted the CommonJS module approach before the ES6 proposal, and the two approaches are not interchangeable). You can learn more about Node’s ES6 support here.</description></item><item><title>Event Loop &amp; Console</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/02-event-loop/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/02-event-loop/index.html</guid><description>Node adopts an asynchronous event-driven approach to computing, much like JavaScript does in the browser. For example, when we set up a HTTP server in Node, we define a function to call when a HTTP request (an event) is received. As requests come in, they are added to a queue which is processed in a FIFO (first-in, first-out) manner.</description></item><item><title>Asynchronous Functions</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.html</guid><description>The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn’t been read yet.</description></item><item><title>Modules</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/04-modules/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/04-modules/index.html</guid><description>One major feature Node introduced to JavaScript was the ability to encapsulate code into separate files using modules. The approach adopted by Node is the CommonJS module pattern.
Warning Node’s use of modules predates ECMA6’s adoption of modules, and the CommonJS approach Node adopted is fundamentally different than the ECMA6 version. For Node 16 (installed on your Codio Box), ECMA6 modules are an optional feature that has to be enabled with a flag when invoking the node command, i.e.:</description></item><item><title>Packages</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/05-packages/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/05-packages/index.html</guid><description>The Node Package Manager allows you to create a package representing your project. This is similar to Visual Studio’s idea of a project - a package is a complete Node program.
Just as Visual Studio adds solution and project files, a Node package adds a file named package.json and a directory named node_modules.
The Package File Every node package has in its top-level directory a file named package.json. This JSON file provides important information about the project, including:</description></item><item><title>Dependencies</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/06-dependencies/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/06-dependencies/index.html</guid><description>A second great benefit of creating your project as a Node package is that dependencies can be managed using the Node Package Manager (npm). You can install any Node package with the command $npm install [package name]. This command looks for the corresponding package in an online repository, and if it is found, downloads it and saves it to the subdirectory node_modules in your package directory.
It also creates an entry in the package.json file corresponding to the package you installed, and also an entry in the package.lock.json file. The entry in your package.json file may specify a specific version, i.e.:</description></item><item><title>Git</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/07-git/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/07-git/index.html</guid><description>Most Node packages are made available as git repositories, and npm has built-in support for using git.
The Repository Property In your package.json file, you can specify a "repository" property, which specifies where the repository for this project exists. Consider the following example of the npm command-line interface package:
"repository": { "type" : "git", "url" : "https://github.com/npm/cli.git" } For many open-source projects, the repository is located on Github, a GitHub gist, BitBucket, or a GitLab instance. These can be specified with a shorthand, which matches the corresponding npm install argument:</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/08-summary/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/04-node/08-summary/index.html</guid><description>Node, and its package manager, npm, are powerful tools for developing server-side applications in JavaScript. In the past chapter, we’ve discussed the event loop that drives Node’s asynchronous, event-driven approach, and the asynchronous function pattern employed by many node libraries. We’ve also talked about how Node.js code can be organized into modules, how those modules can be imported with a require() call, and how the node package manager (npm) can be used to download and install open-source packages locally. Finally, we’ve discussed how to create our own local packages from our projects.</description></item></channel></rss>