<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn’t been read yet."><meta name=author content="Nathan Bean & Russell Feldhausen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta name=twitter:title content="Asynchronous Functions :: CIS 526 Textbook"><meta name=twitter:description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn’t been read yet."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.html"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Asynchronous Functions :: CIS 526 Textbook"><meta property="og:description" content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn’t been read yet."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Introduction to Node"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-06-27T14:51:29-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta itemprop=name content="Asynchronous Functions :: CIS 526 Textbook"><meta itemprop=description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn’t been read yet."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-06-27T14:51:29-05:00"><meta itemprop=wordCount content="519"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><title>Asynchronous Functions :: CIS 526 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.html rel=canonical type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/index.xml rel=alternate type=application/rss+xml title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/index.print.html rel=alternate type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/tele.html rel=alternate type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/css/auto-complete/auto-complete.min.css?1769117712 rel=stylesheet><script src=/cis526/js/auto-complete/auto-complete.min.js?1769117712 defer></script><script src=/cis526/js/search-lunr.min.js?1769117712 defer></script><script src=/cis526/js/search.min.js?1769117712 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis526/searchindex.en.js?1769117712"</script><script src=/cis526/js/lunr/lunr.min.js?1769117712 defer></script><script src=/cis526/js/lunr/lunr.stemmer.support.min.js?1769117712 defer></script><script src=/cis526/js/lunr/lunr.multi.min.js?1769117712 defer></script><script src=/cis526/js/lunr/lunr.en.min.js?1769117712 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1769117712 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1769117712 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar/perfect-scrollbar.min.css?1769117712 rel=stylesheet><link href=/cis526/css/theme.min.css?1769117712 rel=stylesheet><link href=/cis526/css/format-html.min.css?1769117712 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/04-node/03-asynchronous-functions/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis526/css/custom.css?1769117712 rel=stylesheet></head><body class="mobile-support embed html" data-url=/cis526/04-node/03-asynchronous-functions/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 04-node" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=asynchronous-functions>Asynchronous Functions</h1><p>The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.</p><p>Consider the two approaches for reading and printing the contents of a file, below:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;fs&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Synchronous approach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFileSync</span>(<span style=color:#e6db74>&#39;file.txt&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Asynchronous approach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#39;file.txt&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>){
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>});</span></span></code></pre></div><p>In the synchronous function, the contents of the file are <em>returned</em>, and assigned to the variable <code>data</code>. Conversely, in the asynchronous approach the file contents are passed into a <em>callback</em> function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (<code>undefined</code> in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn&rsquo;t been read yet.</p><h2 id=asynchronous-callback-structure>Asynchronous Callback Structure</h2><p>In most Node libraries, the callback function provided to the asynchronous function follows the same format - the first parameter is an error value, which will be populated with text or object if an error occurred, and otherwise will be a <strong>falsy</strong> value (a value that evaluates to false, like <code>false</code>, <code>null</code>, <code>undefined</code>, or <code>0</code>). Successive arguments are the data the function was intended to retrieve - i.e. the contents of the file in the above example. Of course, if an error <em>was</em> encountered, the later values may be wrong. Thus, most programmers follow the pattern of checking for an error at the start of the callback, and halting execution if one is encountered. Rewriting the example above, we would see:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#34;file.txt&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>err</span>) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>); 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>});</span></span></code></pre></div><p>If <code>err</code> is a <strong>truthy</strong> value (any non-falsy value, in this case an Exception object or a string), we log the error to the console and return, halting execution of the rest of the function.</p><h2 id=common-asynchronous-misconceptions>Common Asynchronous Misconceptions</h2><p>It is very important to understand that the callback is <em>executed at a future point in time</em>, and execution continues to further lines of code. Consider this example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>contents</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#34;example.txt&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>contents</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>contents</span>);</span></span></code></pre></div><p>Assuming the file <em>example.txt</em> contains only the line <code>"hello world"</code>, what do you think is printed?</p><p>You might think that it would be <code>"hello world"</code>, but the <code>console.log(data)</code> happens <em>before</em> the callback function is executed, so it will be <code>undefined</code>. If you wanted to print the file contents, you would have to instead do something like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>contents</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#34;example.txt&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>contents</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>contents</span>);
</span></span><span style=display:flex><span>});</span></span></code></pre></div><p>Because the logging now happens <em>inside</em> the callback value, it will only occur <em>after</em> the file has been read, and the results added to the event queue, which is where the <code>contents</code> variable is initialized.</p><details open class="box cstyle notices info"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-info-circle"></i>
Info</summary><div class=box-content><p><a href=https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/07-promises/ rel=external target=_blank>Promises</a> and the <a href=https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/08-async-await/ rel=external target=_blank>async/await</a> keywords covered in the previous chapter are both attempts to sidestep these misconceptions by introducing new objects and syntax that provide more familiar abstractions to programmers.</p></div></details><footer class=footline></footer></article></div></main></div><script src=/cis526/js/clipboard/clipboard.min.js?1769117712 defer></script><script src=/cis526/js/perfect-scrollbar/perfect-scrollbar.min.js?1769117712 defer></script><script src=/cis526/js/theme.min.js?1769117712 defer></script><script src=/cis526/js/embed-iframe.min.js?1769117712 defer></script></body></html>