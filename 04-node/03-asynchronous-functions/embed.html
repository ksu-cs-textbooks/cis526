<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs."><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Asynchronous Functions :: CIS 526 Textbook"><meta name=twitter:description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/embed.html"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Asynchronous Functions :: CIS 526 Textbook"><meta property="og:description" content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Introduction to Node"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-06-27T14:51:29-05:00"><meta itemprop=name content="Asynchronous Functions :: CIS 526 Textbook"><meta itemprop=description content="The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-06-27T14:51:29-05:00"><meta itemprop=wordCount content="515"><title>Asynchronous Functions :: CIS 526 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/ rel=canonical type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/index.xml rel=alternate type=application/rss+xml title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/index.print.html rel=alternate type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/04-node/03-asynchronous-functions/tele.html rel=alternate type=text/html title="Asynchronous Functions :: CIS 526 Textbook"><link href=/cis526/css/fontawesome-all.min.css?1737994990 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fontawesome-all.min.css?1737994990 rel=stylesheet></noscript><link href=/cis526/css/nucleus.css?1737994990 rel=stylesheet><link href=/cis526/css/auto-complete.css?1737994990 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/auto-complete.css?1737994990 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar.min.css?1737994990 rel=stylesheet><link href=/cis526/css/fonts.css?1737994990 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fonts.css?1737994990 rel=stylesheet></noscript><link href=/cis526/css/theme.css?1737994990 rel=stylesheet><link href=/cis526/css/theme-light-theme.css?1737994990 rel=stylesheet id=R-variant-style><link href=/cis526/css/chroma-relearn-light.css?1737994990 rel=stylesheet id=R-variant-chroma-style><link href=/cis526/css/variant.css?1737994990 rel=stylesheet><link href=/cis526/css/print.css?1737994990 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.index_js_url="/cis526/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis526/css/custom.css?1737994990 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis526/04-node/03-asynchronous-functions/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><p>The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.</p><p>Consider the two approaches for reading and printing the contents of a file, below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Synchronous approach
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>readFileSync</span><span class=p>(</span><span class=s1>&#39;file.txt&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Asynchronous approach
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s1>&#39;file.txt&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span></span></span></code></pre></div><p>In the synchronous function, the contents of the file are <em>returned</em>, and assigned to the variable <code>data</code>. Conversely, in the asynchronous approach the file contents are passed into a <em>callback</em> function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (<code>undefined</code> in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasn&rsquo;t been read yet.</p><h2 id=asynchronous-callback-structure>Asynchronous Callback Structure</h2><p>In most Node libraries, the callback function provided to the asynchronous function follows the same format - the first parameter is an error value, which will be populated with text or object if an error occurred, and otherwise will be a <strong>falsy</strong> value (a value that evaluates to false, like <code>false</code>, <code>null</code>, <code>undefined</code>, or <code>0</code>). Successive arguments are the data the function was intended to retrieve - i.e. the contents of the file in the above example. Of course, if an error <em>was</em> encountered, the later values may be wrong. Thus, most programmers follow the pattern of checking for an error at the start of the callback, and halting execution if one is encountered. Rewriting the example above, we would see:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s2>&#34;file.txt&#34;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=k>return</span> <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=nx>err</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span></span></span></code></pre></div><p>If <code>err</code> is a <strong>truthy</strong> value (any non-falsy value, in this case an Exception object or a string), we log the error to the console and return, halting execution of the rest of the function.</p><h2 id=common-asynchronous-misconceptions>Common Asynchronous Misconceptions</h2><p>It is very important to understand that the callback is <em>executed at a future point in time</em>, and execution continues to further lines of code. Consider this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s2>&#34;example.txt&#34;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>contents</span> <span class=o>=</span> <span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>contents</span><span class=p>);</span></span></span></code></pre></div><p>Assuming the file <em>example.txt</em> contains only the line <code>"hello world"</code>, what do you think is printed?</p><p>You might think that it would be <code>"hello world"</code>, but the <code>console.log(data)</code> happens <em>before</em> the callback function is executed, so it will be <code>undefined</code>. If you wanted to print the file contents, you would have to instead do something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s2>&#34;example.txt&#34;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>contents</span> <span class=o>=</span> <span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span></span></span></code></pre></div><p>Because the logging now happens <em>inside</em> the callback value, it will only occur <em>after</em> the file has been read, and the results added to the event queue, which is where the <code>contents</code> variable is initialized.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p><a href=https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/07-promises/ rel=external target=_blank>Promises</a> and the <a href=https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/08-async-await/ rel=external target=_blank>async/await</a> keywords covered in the previous chapter are both attempts to sidestep these misconceptions by introducing new objects and syntax that provide more familiar abstractions to programmers.</p></div></div><footer class=footline></footer></article></div></main></div><script src=/cis526/js/clipboard.min.js?1737994990 defer></script><script src=/cis526/js/perfect-scrollbar.min.js?1737994990 defer></script><script src=/cis526/js/theme.js?1737994990 defer></script><script src=/cis526/js/embed-iframe.js?1737994990 defer></script></body></html>