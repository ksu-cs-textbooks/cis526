<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Asynchronous Functions :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.html</link><description>The benefit of the asynchronous approach is that all user-written code runs in a single-threaded environment while avoiding blocking. This means for the most part, we can write code the way we are used to, with a few tweaks for asynchronous functions.
Consider the two approaches for reading and printing the contents of a file, below:
const fs = require('fs'); // Synchronous approach var data = fs.readFileSync('file.txt'); console.log(data); // Asynchronous approach fs.readFile('file.txt', function(err, data){ console.log(data); }); In the synchronous function, the contents of the file are returned, and assigned to the variable data. Conversely, in the asynchronous approach the file contents are passed into a callback function that is invoked when the asynchronous process finishes (and when the callback phase of the Node event loop is reached). The function itself returns nothing (undefined in Node). The important difference between the two is in the first approach, the program waits for the file to be read. In the second, the program keeps executing lines of code after the asynchronous call, even though the file hasnâ€™t been read yet.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate/><atom:link href="https://textbooks.cs.ksu.edu/cis526/04-node/03-asynchronous-functions/index.xml" rel="self" type="application/rss+xml"/></channel></rss>