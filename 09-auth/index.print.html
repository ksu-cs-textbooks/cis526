<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Who are you?"><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Authentication :: CIS 526 Textbook"><meta name=twitter:description content="Who are you?"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/09-auth/"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Authentication :: CIS 526 Textbook"><meta property="og:description" content="Who are you?"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Authentication :: CIS 526 Textbook"><meta itemprop=description content="Who are you?"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T16:48:12-05:00"><meta itemprop=wordCount content="3"><title>Authentication :: CIS 526 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis526/09-auth/ rel=canonical type=text/html title="Authentication :: CIS 526 Textbook"><link href=/cis526/09-auth/index.xml rel=alternate type=application/rss+xml title="Authentication :: CIS 526 Textbook"><link href=/cis526/09-auth/tele.html rel=alternate type=text/html title="Authentication :: CIS 526 Textbook"><link href=/cis526/09-auth/embed.html rel=alternate type=text/html title="Authentication :: CIS 526 Textbook"><link href=/cis526/css/fontawesome-all.min.css?1744734275 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fontawesome-all.min.css?1744734275 rel=stylesheet></noscript><link href=/cis526/css/nucleus.css?1744734275 rel=stylesheet><link href=/cis526/css/auto-complete.css?1744734275 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/auto-complete.css?1744734275 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar.min.css?1744734275 rel=stylesheet><link href=/cis526/css/fonts.css?1744734275 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fonts.css?1744734275 rel=stylesheet></noscript><link href=/cis526/css/theme.css?1744734275 rel=stylesheet><link href=/cis526/css/theme-auto.css?1744734275 rel=stylesheet id=R-variant-style><link href=/cis526/css/chroma-auto.css?1744734275 rel=stylesheet id=R-variant-chroma-style><link href=/cis526/css/variant.css?1744734275 rel=stylesheet><link href=/cis526/css/print.css?1744734275 rel=stylesheet media=print><link href=/cis526/css/format-print.css?1744734275 rel=stylesheet><script src=/cis526/js/variant.js?1744734275></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.index_js_url="/cis526/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis526/css/custom.css?1744734275 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis526/09-auth/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Authentication</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis526/08-routing/09-summary/ title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis526/09-auth/01-introduction/ title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 9</div><h1 id=authentication>Authentication</h1><p>Who are you?</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Authentication</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>An important part of any dynamic web server is controlling how, and by whom, it is used. This is the domain of authentication and authorization. <em>Authentication</em> refers to mechanisms used to establish the <em>identity</em> of a user, and <em>authorization</em> refers to determining if an authenticated user has permission to do the requested action in the system. Collectively, these two concepts are often referred to by the abbreviation <em>auth</em>.</p><p>Consider a content management system (CMS) - a dynamic website for hosting content created by authorized users. The K-State website is an example of this kind of site - the events, articles, and pages are written by various contributors throughout the university. It is important that only authorized agents of the university (i.e. staff and faculty) are allowed to publish this content. Can you imagine what would happen if <em>anyone</em> could post <em>anything</em> on the K-State website?</p><p>In this chapter, we&rsquo;ll examine strategies for performing both authentication and authorization.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=http-authentication>HTTP Authentication</h1><p>The recognition of a need for authentication is not new to the web - it&rsquo;s been there since the earliest standards. In fact, the original URL specification included an optional username and password as part of its format (specified as <code>[username]:[password]@</code> between the protocol and host). I.e. to make a HTTP authenticated request against the CS departmental server you might use:</p><div class=highlight><pre tabindex=0><code>https://willie:purpleandwhite@cs.ksu.edu/</code></pre></div><p>However, the use of authentication URLS is now highly discouraged and has been stripped from most browsers, as it is considered a security risk. Instead, if you are using <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication rel=external target=_blank>HTTP-based authentication</a> the server needs to issue a challenge <strong>401 Unauthorized</strong> response, along with a <code>WWW-Authenticate</code> header specifying the challenge. This will prompt the browser to display a username/password form and will re-submit the request with the credentials using an <code>Authorization</code> header. The process looks something like this:</p><p><a href=#R-image-37541a964df8ea9be8c1d57f8d7be29e class=lightbox-link><img alt="The HTTP Authentication process" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/9.2.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-37541a964df8ea9be8c1d57f8d7be29e><img alt="The HTTP Authentication process" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/9.2.1.png></a></p><p>As you can see, when the client makes a request that requires authentication, the server issues a <strong>401 Unauthorized</strong> status code, along with an <code>WWW-Authenticate</code> header specifying the authentication scheme. This prompts the browser to request the user credentials via a dialog (much like the one created by the JavaScript functions <code>alert()</code>, <code>confirm()</code>, and <code>prompt()</code>). If the user supplies credentials, the request is re-sent, with those credentials included in an <code>Authentication</code> header. The server then decides, based on the credentials, if it will allow the request (typically a <strong>200</strong> response), or refuse (a <strong>403 Unauthorized</strong> response).</p><p>The <code>WWW-Authenticate</code> header looks like:</p><div class=highlight><pre tabindex=0><code>WWW-Authenticate: [type] realm=[realm]</code></pre></div><p>Where <code>[type]</code> is the authentication scheme (<code>Basic</code> being the most common), and <code>realm</code> describing the protected part of the server.</p><p>In the Basic authentication scheme, the content of the <code>Authorization</code> header is the string <code>[username]:[password]</code> encoded in <a href=https://en.wikipedia.org/wiki/Base64 rel=external target=_blank>base64</a>, where <code>[username]</code> is the users&rsquo; username, and <code>[password]</code> is their password.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Base64 encoding is easy to undo, so you should only use HTTP Basic Authentication with the <code>https</code> protocol, which encrypts the request headers. Otherwise, anyone along the path the user&rsquo;s request travels can capture and decrypt the user&rsquo;s credentials.</p></div></div><p>The standard also defines other authorization schemes, but none are widely used today. Instead, most web developers have opted to build authentication directly into their web application. We&rsquo;ll discuss several of the most common approaches next.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=password-authentication>Password Authentication</h1><p>One of the more common approaches used in modern dynamic webservers - especially those that are already using a database - is to have each user create an account and log in with a username and password. The primary difference in this approach from the HTTP Basic one is that:</p><ol><li>The webserver provides a login page with a form for submitting the username/password (allowing it to be customized to match the site)</li><li>On an successful authentication, a cookie is used to persist the user&rsquo;s session, rather than re-submitting the <code>Authentication</code> header</li></ol><p>The actual difference in your server code between the two approaches is not that large.</p><h2 id=storing-user-credentials>Storing User Credentials</h2><p>In either case, it is necessary for the server to be able to verify that the user&rsquo;s supplied credentials are correct. For most database-backed dynamic webservers, this is accomplished by having a <em>users</em> table that stores the username, and an <strong>transformed</strong> version of the password. This transformation is usually accomplished through the use of a <a href=https://en.wikipedia.org/wiki/Cryptographic_hash_function rel=external target=_blank>cryptographic hash function</a>. This is a function that converts a string into a sequence of bytes that are very different from the source string. It is also a function that is <em>extremely difficult to reverse</em> i.e. it is difficult to figure out what the original string was from the hashed results.</p><p>When authenticating the user, the password supplied by the user is hashed using the same function, and the resulting hash is compared to the one stored in the database. If they match, the user is confirmed, and can be logged in.</p><p>The reason we store passwords only in this encrypted form is that if an adversary was able to compromise our database and obtain the <em>users</em> table, they still wouldn&rsquo;t know the users&rsquo; passwords. Even with the contents of the database, the adversary would not be able to log in to our server as the user. And, as most users use the same password and email for multiple sites, this gives them some additional protection.</p><p>In fact, current best practice is to do more than just encrypt the password - we also use salt and multiple hashing rounds.</p><h3 id=salting-a-password>Salting a Password</h3><p>Salting a password simply means to append a series of characters to the user&rsquo;s password before hashing it. This helps avoid <a href=https://en.wikipedia.org/wiki/Rainbow_table rel=external target=_blank>rainbow table</a> attacks, where an adversary uses a list of prehashed commonly-used passwords. Since many users adopt simple passwords like <strong>1234</strong>, <strong>secret</strong>, etc., it is a good bet that if you <em>do</em> obtain a list of usernames and their hashed passwords, you can find some matches. Appending the additional characters (usually in the form of random bytes) can prevent this. For an even stronger approach, <em>two</em> salts can be used - one stored as an server or environment variable, and one randomly generated per user and stored in the users table. Thus, the adversary would need to obtain access to both the database <em>and</em> the source code or server environment, making attacks more difficult.</p><h3 id=multiple-hashing-rounds>Multiple Hashing Rounds</h3><p>Unfortunately, computing hardware has advanced to the point that <a href=https://en.wikipedia.org/wiki/Brute-force_attack rel=external target=_blank>brute force attacks</a> have become more than plausible. In a brute-force approach, permutations of characters are hashed until a match is found. A cluster of off-the-shelf graphics cards can make as many as 350 billion guesses each second. The defense against this approach is to make it take longer. Cryptographic hash functions like <a href=https://en.wikipedia.org/wiki/Bcrypt rel=external target=_blank>Bcrypt</a> allow the hashing to be performed in multiple iterations. Adding more iterations makes the encryption process take longer - and therefore slows down any brute-force attack replicating the hashing function.</p><p>The downside is that it takes longer to log a user in using this strategy, but it provides about the best protection that we as web developers can offer. Incidentally, this is another reason to only authenticate the user once, rather than on every request (as is the case with HTTP authentication). To be able to store the user&rsquo;s authentication however, we must maintain some form of session.</p><h2 id=user-sessions>User Sessions</h2><p>This brings us to the second half of the username/password approach - we have to implement some form of user session. To do user sessions, we must also employ cookies. By their nature, cookies are not as secure as we might like, but there are some strategies we can use to make them more secure. First, we should specify the cookies using the <code>Secure</code> and <code>HttpOnly</code> attributes, and the <code>SameSite</code> attribute set to <code>Strict</code>. Moreover, the values set in the cookie should also be encrypted before being set (in this case, with a two-way encryption). Commonly, only the session id or user id will be included in the cookie, while the actual session data will be stored server-side in memory or in a sessions table.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>As with HTTP Authentication (and indeed, all authentication approaches) password-based authentication should only be used with HTTPS connections.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=stronger-passwords>Stronger Passwords</h1><p>Now that we&rsquo;ve discussed how to build a password-based authentication system as securely as possible, we should take a moment to understand what <em>makes a good password</em>. While we can&rsquo;t force users to use good passwords, we can encourage them to do so, and potentially build some requirements/guidance into our sign up forms.</p><p>You&rsquo;ve likely been told multiple times that a good password is a mix of numbers, upper- and lower-case letters, and special symbols. While this is indeed marginally better than a password of the same length that uses only letters, it isn&rsquo;t much. Remember that with some clever programming and a graphics card, passwords can be brute-forced. The amount of time this takes is more dependent on the <em>length</em> of the password than the combination of characters. This XKCD comic sums up the issue succinctly:</p><p><a href=#R-image-31acd007375c0dd4ee74993d4afbe5d7 class=lightbox-link><img alt="XKCD: Password Strength" class="border lazy lightbox noshadow figure-image" loading=lazy src=https://imgs.xkcd.com/comics/password_strength.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-31acd007375c0dd4ee74993d4afbe5d7><img alt="XKCD: Password Strength" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=https://imgs.xkcd.com/comics/password_strength.png></a></p><p>In short, the best passwords are actually <em>pass phrases</em> - a combination of words that is easy to remember and of significant length. Given this is mathematically demonstrable, why do so many authentication services insist on a complex scheme for making short passwords? I suspect it is a legacy from when storage space was at a premium, as well as a nod to database performance.</p><p>Think back to our SQL discussions - we can declare text in two ways - a VARCHAR (which has a set maximum length), or TEXT (which can be any size). These roughly correspond to <em>value</em> and <em>reference</em> types in a programming language - VARCHARS are stored inline with table data, while TEXT entries are stored separately, and an address of their location is stored in the table. If we&rsquo;re retrieving thousands or millions of rows including TEXT values, we have to pull those values from their disparate locations - adding overhead to the query. VARCHARS we get with the row for no extra time cost. So storing passwords as a VARCHAR would give better performance, and limiting them to a small size (by imposing a character limit) would save on storage requirements.</p><p>In the modern web, with storage costs as low as they are, there is no excuse for clinging to short passwords with arcane requirements. If you are going to force your users to meet any rules for your password system, it should be a <em>minimum length</em>.</p><p>Or, we can side-step the issue entirely, by passing responsibility for authentication to a third party. We&rsquo;ll look at these strategies next.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=single-sign-on>Single Sign On</h1><p>It should be clear from our earlier discussion that there are some very real challenges to writing a good authentication approach. These challenges can be broken into two categories, those that face us as the programmer, and those that arise from our users:</p><h4 id=programmer-challenges>Programmer Challenges</h4><p>For us as the programmer, there are a lot of steps in creating an authentication strategy that we <em>must</em> get right. We also must be very careful about how we store the authentication data - i.e. passwords should <strong>always</strong> be stored encrypted, never as plain text. And having actual authentication data in our site makes us a juicer target for adversaries, and potentially ups the stakes if our site is compromised.</p><p>Finally, what constitutes best practice in authentication <em>is constantly changing</em>. And to make sure we are doing everything as securely as possible <em>we should be updating our apps to follow current best practices.</em> This is obviously a lot of work.</p><h4 id=user-challenges>User Challenges</h4><p>For the user, having <em>yet another login and password</em> contributes to a number of problems. Users struggle to remember multiple passwords, and often default to using the <em>same</em> login and password across multiple sites. This means their credentials are only as secure as the worst-implemented security of those sites. While your app might have stellar security, your user might be compromised by a completely different site you have no influence over. Also, users often resort to writing down credentials - leaving them open to being found and used by others.</p><h3 id=single-sign-on>Single Sign On</h3><p>Single-sign on is a solution to both sets of challenges. The basic idea is to have one authentication service that is used for multiple, often completely independent applications. A user only needs to remember one login and password for <em>all</em> the applications, and authentication is done on one special-built server that can be updated to the latest best practices with ease.</p><p>Of course, to implement single-sign on, we need a way to establish trust between the authenticating server and the other web apps that use it. Thus, we need a standardized process to draw upon. We&rsquo;ll discuss several in the next couple of sections.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cas>CAS</h1><p>Let&rsquo;s start our discussion of single-sign on strategies with Central Authentication Service (CAS). We&rsquo;ll do this because it is one of the more straightforward approaches to Single Sign On, and one you&rsquo;ve probably used every day as a K-State student, as it is the basis of Kansas State University&rsquo;s eid login system.</p><p>CAS is a standard protocol that involves two servers and the client computer. One server is the host of the app and the other is the authentication server. The flow is fairly straightforward:</p><ol><li><p>The user visits the app server, which determines the user is not logged in</p></li><li><p>The app server redirects the browser to the authentication server, providing in the url as a query parameter URL to return the authenticated user to</p></li><li><p>The authentication server sends the browser a login form</p></li><li><p>The user fills out and submits the form, which goes back to the authentication server</p></li><li><p>If the authentication is unsuccessful, the authentication server re-sends the form (returning to step 3). If it is successful, the authentication server redirects the user to the app server, using the URL it provided in the first redirect. It also sends a ticket (a string of cryptographic random bytes) that corresponds to the login attempt as a query parameter</p></li><li><p>The app server now has to verify that the ticket it received is valid (i.e. it is not counterfeit or an re-used one captured from an earlier login attempt). To do this, the app server sends a request to validate the ticket to the authentication server</p></li><li><p>If the authentication server sends an XML response indicating if the ticket was valid. If it is valid, this XML also includes information about the user (at a minimum the username, but it can contain additional information like email, first and last names, etc).</p></li><li><p>Once the app server is sure the ticket is valid, it finishes logging in the user (typically by saving their identity in a session) and sends a welcome page or the page they were attempting to access.</p></li></ol><p>The diagram below visually shows this process:</p><img src=https://miro.medium.com/max/1050/1*yCpUC4xPxtYV-LKbUv_TmQ.jpeg alt="The CAS login process"><p>You can learn more about the CAS approach at <a href=https://www.apereo.org/projects/cas rel=external target=_blank>https://www.apereo.org/projects/cas</a>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=saml>SAML</h1><p>Security Assertion Markup Language (SAML) is a similar single-sign-on strategy to CAS, but one that has a wider adoption in the business world. The process is quite similar, with the addition that the user agent identifies the user before requesting access. How it does so is left to the implementer, but it can be an IP address, stored token, or other means.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/0/04/Saml2-browser-sso-redirect-post.png alt="SAML Web Browser Single-Sign On flow"><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>Much like CAS, SAML provides its response in the form of XML. And like CAS, the SAML standard primarily works with traditional, server-based web apps. We&rsquo;ll turn to some alternatives next.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>File:Saml2-browser-sso-redirect-post.png. (2021, October 17). Wikimedia Commons, the free media repository. Retrieved 15:33, June 2, 2022 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Saml2-browser-sso-redirect-post.png&oldid=599388084" rel=external target=_blank>https://commons.wikimedia.org/w/index.php?title=File:Saml2-browser-sso-redirect-post.png&oldid=599388084</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=json-web-tokens>JSON Web Tokens</h1><p>A common thread across single-sign-on approaches is the issuing of some kind of ticket or certificate to identify the signed-in user. This is often stored within a cookie (which means it can be used to persist a connection with a web app). However, as the web matured, a more robust identity token became a standard: the JSON Web Token (JWT).</p><p>A JSON Web Token (JWT) consists of three parts:</p><ul><li>A header with metadata</li><li>A payload consisting of the data needed to identify the user</li><li>A cryptographic signature verifying the payload and header</li></ul><p>The JWT puts the user information directly into a token that is served by the authentication server. So if we want to identify a user by email, their email is in the payload. The header provides information like when the JWT will expire, and what cryptographic algorithm was used to generate the signature. And the signature was created using the specified cryptographic algorithm on the header and payload. This signature is what gives a JWT its robustness; when used correctly makes it impossible to modify the payload without the tampering being evident.</p><p>How trust is established is based on the cryptographic function, which uses a public and private key pair (much like TLS). The hash is <em>created</em> with the private key on the authentication server on a successful login. It can be <em>decoded</em> by an application using the <em>public</em> key. The decoded data should match that of the header and payload <em>exactly</em>. If it does, this proves the JWT was created by the authentication server (as you can&rsquo;t create one without the private key) and hasn&rsquo;t been tampered with. If it <em>is</em> tampered with, i.e someone changes the payload, the signature will no longer match.</p><p>Because of this tamper-resistant nature, JWT has quickly become a standard form for authentication tokens.</p><p>You can learn more about the JWT approach at <a href=https://jwt.io/ rel=external target=_blank>https://jwt.io/</a>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=oauth>OAuth</h1><p>OAuth 2.0 is perhaps the best-known single-sign-on solution. Many of the big internet players provide OAuth services: Google, Microsoft, Facebook, Twitter, etc. However, OAuth is significantly more complex than the other approaches we&rsquo;ve talked about, as it really a standard for <em>access delegation</em>, i.e. a way for users to authorize third-party apps to access their information stored with the identity provider.</p><p>I.e. if you write an app that works with the Facebook API and needs access to a users&rsquo; friends list, then OAuth allows you to authorize Facebook to share that info with your app. This authorization is done by the user through Facebook, and can be revoked at any time.</p><p>Despite being built to help with access delegation, OAuth 2.0 can (and often is) used soley for the purpose of single-sign-on.</p><p>The OAuth protocol flow</p><ol><li>The user requests a resource</li><li>The app server redirects the user&rsquo;s browser to the identity server, along with a a request for identity</li><li>The identity server prompts the user to log in (if they aren&rsquo;t already)</li><li>The identity server redirects the user back to the app server providing an encoded response and identity token (typically a JWT)</li><li>The app server <em>decodes</em> the response, and determines if the user has been authenticated</li><li>The identity token can now be used to access the approved services of the identity provider</li></ol><p>Notice the big difference here between CAS and SAML is that the app server doesn&rsquo;t need to contact the identity server directly to authenticate the user. This is because the app server is <em>registered</em> with the identity server, which provides it both an client id and secret. The client id is a public identifier used to uniquely identify the web app amongst all those that use the identity service, and the secret <em>should be</em> known only to the web app and the identity server. This client id, secret, and user&rsquo;s token are sent to the authenticating server when requests are made for its services.</p><p>OAuth is sometimes referred to as pseudo-identity, as its real purpose is to provide access to the services of the identity provider. OpenID is another standard built on top of OAuth that goes one step farther - issuing an authentication certificate certifying the identity of the user. A comparison of the two processes appears in the graphic below:</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/3/32/OpenIDvs.Pseudo-AuthenticationusingOAuth.svg alt=Oauth> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>File:OpenIDvs.Pseudo-AuthenticationusingOAuth.svg. (2020, October 22). Wikimedia Commons, the free media repository. Retrieved 15:38, June 2, 2022 from <a href="https://commons.wikimedia.org/w/index.php?title=File:OpenIDvs.Pseudo-AuthenticationusingOAuth.svg&oldid=496954680" rel=external target=_blank>https://commons.wikimedia.org/w/index.php?title=File:OpenIDvs.Pseudo-AuthenticationusingOAuth.svg&oldid=496954680</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>In this chapter we discussed many of the possible authentication strategies for web applications, as well as the strengths and drawbacks. To reiterate the most salient points:</p><ul><li>Passwords should <strong>NEVER</strong> be stored as plain text!</li><li>Authentication processes should follow <em>current</em> industry best-practices. This is not the place to experiment!</li><li>Industry best practices are constantly changing, as ever-improving computer technology renders older techniques ineffective</li></ul><p>Following these guidelines can help keep your users safe and secure. Or you can use a singe-sign-on solution to allow another service to take on the responsibility for authentication. But if you do, you must follow the standard <em>exactly</em>, and protect any secrets or private keys involved. Failing to do so will expose your users&rsquo; data.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis526/commit/41163dc548a00400a9f1d4962b4227b9a8ee4d20>Aug 10, 2023</a></p></div></div><script src=/cis526/js/clipboard.min.js?1744734275 defer></script><script src=/cis526/js/perfect-scrollbar.min.js?1744734275 defer></script><script src=/cis526/js/theme.js?1744734275 defer></script></body></html>