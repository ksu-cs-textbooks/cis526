<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="As JavaScript began to be used to add more and more functionality to web applications, an important limitation began to appear. When the JavaScript interpreter is working on a big task, it stays in the event loop a long time, and does not pull events from the event queue. The result is the browser stops responding to user events… and seems to be frozen. On the other hand - some programs will never end. Consider this one:"><meta name=author content="Nathan Bean & Russell Feldhausen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta name=twitter:title content="Web Workers :: CIS 526 Textbook"><meta name=twitter:description content="As JavaScript began to be used to add more and more functionality to web applications, an important limitation began to appear. When the JavaScript interpreter is working on a big task, it stays in the event loop a long time, and does not pull events from the event queue. The result is the browser stops responding to user events… and seems to be frozen. On the other hand - some programs will never end. Consider this one:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/05-web-workers/index.html"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Web Workers :: CIS 526 Textbook"><meta property="og:description" content="As JavaScript began to be used to add more and more functionality to web applications, an important limitation began to appear. When the JavaScript interpreter is working on a big task, it stays in the event loop a long time, and does not pull events from the event queue. The result is the browser stops responding to user events… and seems to be frozen. On the other hand - some programs will never end. Consider this one:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Asynchronous JavaScript"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2025-01-27T10:26:10-06:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta itemprop=name content="Web Workers :: CIS 526 Textbook"><meta itemprop=description content="As JavaScript began to be used to add more and more functionality to web applications, an important limitation began to appear. When the JavaScript interpreter is working on a big task, it stays in the event loop a long time, and does not pull events from the event queue. The result is the browser stops responding to user events… and seems to be frozen. On the other hand - some programs will never end. Consider this one:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2025-01-27T10:26:10-06:00"><meta itemprop=wordCount content="1248"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><title>Web Workers :: CIS 526 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis526/03-asynchronous-js/05-web-workers/index.html rel=canonical type=text/html title="Web Workers :: CIS 526 Textbook"><link href=/cis526/03-asynchronous-js/05-web-workers/index.xml rel=alternate type=application/rss+xml title="Web Workers :: CIS 526 Textbook"><link href=/cis526/03-asynchronous-js/05-web-workers/index.print.html rel=alternate type=text/html title="Web Workers :: CIS 526 Textbook"><link href=/cis526/03-asynchronous-js/05-web-workers/embed.html rel=alternate type=text/html title="Web Workers :: CIS 526 Textbook"><link href=/cis526/css/auto-complete/auto-complete.min.css?1753540871 rel=stylesheet><script src=/cis526/js/auto-complete/auto-complete.min.js?1753540871 defer></script><script src=/cis526/js/search-lunr.min.js?1753540871 defer></script><script src=/cis526/js/search.min.js?1753540871 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis526/searchindex.en.js?1753540871"</script><script src=/cis526/js/lunr/lunr.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.stemmer.support.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.multi.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.en.min.js?1753540871 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1753540871 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1753540871 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar/perfect-scrollbar.min.css?1753540871 rel=stylesheet><link href=/cis526/css/theme.min.css?1753540871 rel=stylesheet><link href=/cis526/css/format-html.min.css?1753540871 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/03-asynchronous-js/05-web-workers/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis526/css/custom.css?1753540871 rel=stylesheet></head><body class="mobile-support html" data-url=/cis526/03-asynchronous-js/05-web-workers/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 03-asynchronous-js" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=web-workers>Web Workers</h1><p>As JavaScript began to be used to add more and more functionality to web applications, an important limitation began to appear. When the JavaScript interpreter is working on a big task, it stays in the event loop a long time, and does not pull events from the event queue. The result is the browser stops responding to user events&mldr; and seems to be frozen. On the other hand - some programs will <em>never</em> end. Consider this one:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;thinking...&#34;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This loop has no possible exit condition, so if you ran it in the browser, it would run infinitely long&mldr; and the page would never respond to user input, because you&rsquo;d never pull any events of the event queue. One of the important discoveries in computer science, the <a href=https://en.wikipedia.org/wiki/Halting_problem rel=external target=_blank>Halting Problem</a> tackles exactly this issue - and Alan Turing&rsquo;s proof shows that a program to determine if another program will halt for all possible programs <em>cannot</em> be written.</p><p>Thus, browsers instead post warning messages after execution has run for a significant amount of time, like this one:</p><p><a href=#R-image-4b7b0124a3c4aa1313113f4e1d440365 class=lightbox-link><img alt="The Chrome not responding dialog" class="border lazy lightbox figure-image" loading=lazy src=/cis526/images/3.5.1.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-4b7b0124a3c4aa1313113f4e1d440365><img alt="The Chrome not responding dialog" class="border lazy lightbox lightbox-image" loading=lazy src=/cis526/images/3.5.1.jpg></a></p><p>So, if we want to do a long-running computation, and <em>not</em> have the browser freeze up, we needed to be able to run it separately from the thread our event loop is running on. The <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers rel=external target=_blank>web worker</a> provides just this functionality.</p><p>A web worker is essentially another JavaScript interpreter, running a script separate from the main thread. As an interpreter, it has its own event loop and its own memory space. Workers and the main thread can communicate by passing messages, which are copied onto their respective event queues. Thus, communication between the threads is <em>asynchronous</em>.</p><p><a href=#R-image-39abefaa126ccc57b63230f8cf6b1ab4 class=lightbox-link><img alt="The web worker and main thread interpreters passing messages" class="border lazy lightbox figure-image" loading=lazy src=/cis526/images/3.5.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-39abefaa126ccc57b63230f8cf6b1ab4><img alt="The web worker and main thread interpreters passing messages" class="border lazy lightbox lightbox-image" loading=lazy src=/cis526/images/3.5.2.png></a></p><h2 id=an-example>An Example</h2><p>You can see an example of such a web worker by using <a href=../../examples/3.5.1/index.html target=_blank>this link</a> to open another tab in your browser. This example simulates a long-running process of <strong>n</strong> seconds either in the browser&rsquo;s main thread or in a web worker. On the page is also three colored squares that when clicked, shift colors. Try changing the colors of the squares while simulating a several-second process in both ways. See how running the process on the main thread freezes the user interface?</p><h2 id=using-web-workers>Using Web Workers</h2><p>Web workers are actually very easy to use. A web worker is created by constructing a <a href=https://developer.mozilla.org/en-US/docs/Web/API/Worker rel=external target=_blank>Worker</a> object. It takes a single argument - the JavaScript file it will execute (which should be hosted on the same server). In the example, this is done with:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// Set up the web worker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>worker</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Worker</span>(<span style=color:#e6db74>&#39;stall.js&#39;</span>);</span></span></code></pre></div><p>The <em>stall.js</em> file contains the script the worker will execute - we&rsquo;ll take a look at it in a minute.</p><p>Once created, you can attach a listener to the <code>Worker</code>. It has two events:</p><ul><li><code>message</code> - a deserialized message sent from the web worker</li><li><code>mesageerror</code> - a message sent from the web worker that was not serializable</li></ul><p>You can use <code>worker.addEventListener()</code> to add these, or you can assign your event listener to the event handler properties. Those properties are:</p><ul><li><code>Worker.onmessage</code> - triggered when the <code>message</code> event happens</li><li><code>Worker.onmessageerror</code> - triggered when the <code>messageerror</code> event happens</li></ul><p>Additionally, there is an error handler property:</p><ul><li><code>Worker.onerror</code></li></ul><p>Which triggers when an uncaught error occurs on the web worker.</p><p>In our example, we listen for messages using the <code>Worker.onmessage</code> property:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// Set up message listener
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Signal completion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#calculation-message&#39;</span>).<span style=color:#a6e22e>textContent</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`Calculation complete!`</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If the message was successfully deserialized, it&rsquo;s <code>data</code> property contains the content of the message, which can be any valid JavaScript value (an int, string, array, object, etc). This gives us a great deal of flexibility. If you need to send more than one type of message, a common strategy is to send a JavaScript object with a type property, and additional properties as needed, i.e.:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>messageData1</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;greeting&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Hello!  It&#39;s good to see you.&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>messageData2</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;set-color&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>color</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#ffaacc&#34;</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We can send messages <em>to</em> the web worker with <a href=https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage rel=external target=_blank>Worker.postMessage()</a>. Again, these messages can be any valid JavaScript value:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>postMessage</span>(<span style=color:#e6db74>&#34;Foo&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>postMessage</span>(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>postMessage</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;greetings&#34;</span>, <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Take me to your leader!&#34;</span>});</span></span></code></pre></div><p>In our example, we send the number of seconds to wait as an integer parsed from the <code>&lt;input></code> element:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// Get the number to calculate the Fibonacci number for and convert it from a string to a base 10 integer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> parseInt(document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#n&#39;</span>).<span style=color:#a6e22e>value</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Stall for the specified amount of time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>postMessage</span>(<span style=color:#a6e22e>n</span>);</span></span></code></pre></div><p>Whatever data we send as the message is <em>copied</em> into the web worker&rsquo;s memory using the <a href=https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm rel=external target=_blank>structured clone</a> algorithm. We can also optionally <em>transfer</em> objects to the web worker instead of copying them by providing them as a second argument. This transfers the memory holding them from one thread to the other. This makes them unavailable on the original thread, but is much faster than copying when the object is large. It is used for sending objects like <a href=https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer rel=external target=_blank>ArrayBuffer</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort rel=external target=_blank>MessagePort</a>, or <a href=https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap rel=external target=_blank>ImageBitmap</a>. Transferred objects <em>also</em> need to have a reference in the first argument.</p><h2 id=the-web-worker-context>The Web Worker Context</h2><p>For the JavaScript executing in the web worker, the context is a bit different. First, there is no document object model, as the web worker cannot make changes to the user interface. Likewise there is no global <code>window</code> object. However, many of the normal global functions and properties <em>not</em> related to the user interface are available, see <a href=https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers rel=external target=_blank>functions and classes available to web workers</a> for details.</p><p>The web worker has its own unique global scope, so any variables declared in your main thread won&rsquo;t exist here. Likewise, varibles declared in the worker will not exist in the main scope either. The global scope of the worker has mirror events and properties to the <code>Worker</code> - we can listen for messages from the main thread using the <code>onmessage</code> and <code>onmessageerror</code> properties, and send messages back to the main thread with <code>postMessage()</code>.</p><p>The complete web worker script from the example is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>/** @function stall 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Synchronously stalls for the specified amount of time 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * to simulate a long-running calculation
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param {int} seconds - the number of seconds to stall
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>stall</span>(<span style=color:#a6e22e>seconds</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>startTime</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>endTime</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>seconds</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>startTime</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>endTime</span>) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Message handler for messages from the main thread
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// stall for the specified amount of time 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>stall</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Send an answer back to the main thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>postMessage</span>(<span style=color:#e6db74>`Stalled for </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span><span style=color:#e6db74>}</span><span style=color:#e6db74> seconds`</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Close the worker since we create a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// new worker with each stall request.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Alternatively, we could re-use the same
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// worker.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>Workers can also send AJAX requests, and spawn additional web workers! In the case of spawning additional workers, the web worker that creates the child worker is treated as the main thread.</p><h2 id=other-kinds-of-web-workers>Other kinds of Web Workers</h2><p>The web workers we&rsquo;ve discussed up to this point are basic <em>dedicated workers</em>. There are also several other kinds of specialized web workers:</p><ul><li>Shared workers are shared between several scripts, possibly even running in different <code>&lt;iframe></code> elements. These are more complex than a dedicated worker and communicate via ports. See MDN&rsquo;s <a href=https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker rel=external target=_blank>SharedWorker</a> article for information.</li><li>Service workers act as proxy servers between the server and the web app, for the purpose of allowing web apps to be used offline. We&rsquo;ll discuss these later in the semester, but you can read up on them in hte mdn <a href=https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API rel=external target=_blank>ServiceWorker</a> article.</li><li>Audio workers allow for direct scripting of audio processing within a web worker context. See the mdn <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API#Audio_Workers rel=external target=_blank>AudioWorker</a> article for details.</li></ul><footer class=footline></footer></article></div></main></div><script src=/cis526/js/clipboard/clipboard.min.js?1753540871 defer></script><script src=/cis526/js/perfect-scrollbar/perfect-scrollbar.min.js?1753540871 defer></script><script src=/cis526/js/theme.min.js?1753540871 defer></script></div><script src=/cis526/js/tele-scroll.min.js?1753540871 defer></script></body></html>