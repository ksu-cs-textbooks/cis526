<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Authentication :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/</link><description>This example project builds on the previous RESTful API project by adding user authentication. This will ensure users are identified within the system and are only able to perform operations according to the roles assigned to their user accounts.
Project Deliverables At the end of this example, we will have a project with the following features:
An authentication system using Passport.js and CAS Valid JSON Web Tokens (JWTs) for authentication within the RESTful API Proper middleware to verify users have the correct role for each operation in the API Prior Work This project picks up right where the last one left off, so if you haven’t completed that one yet, go back and do that before starting this one.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/index.xml" rel="self" type="application/rss+xml"/><item><title>Bypass Auth</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/01-bypass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/01-bypass/</guid><description>Authentication Libraries There are many different authentication libraries and methods available for Node.js and Express. For this project, we will use the Passport.js library. It supports many different authentication strategy, and is a very common way that authentication is handled within JavaScript applications.
For our application, we’ll end up using several strategies to authenticate our users:
Unique Token - used to bypass authentication for testing CAS - used to authenticate with Central Authentication Service (CAS) servers such as those used at K-State JSON Web Tokens (JWT) - used to identify user requests to the API itself Let’s first set up our unique token strategy, which allows us to test our authentication routes before setting up anything else.</description></item><item><title>Cookie Sessions</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/02-cookie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/02-cookie/</guid><description>Cookie Sessions One of the most common methods for keeping track of users after they are authenticated is by setting a cookie on their browser that is sent with each request. We’ve already explored this method earlier in this course, so let’s go ahead and configure cookie sessions for our application, storing them in our existing database.
We’ll start by installing both the express-session middleware and the connect-session-sequelize library that we can use to store our sessions in a Sequelize database:</description></item><item><title>JSON Web Token</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/03-jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/03-jwt/</guid><description>JSON Web Tokens (JWT) Now that we have a working authentication system, the next step is to configure a method to request a valid JSON Web Token, or JWT, that contains information about the authenticated user. We’ve already learned a bit about JWTs in this course, so we won’t cover too many of the details here.
To work with JWTs, we’ll need to install the jsonwebtoken package from NPM:</description></item></channel></rss>