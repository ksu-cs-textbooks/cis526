<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Authentication :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/</link><description>This example project builds on the previous RESTful API project by adding user authentication. This will ensure users are identified within the system and are only able to perform operations according to the roles assigned to their user accounts.
Project Deliverables At the end of this example, we will have a project with the following features:
An authentication system using Passport.js and CAS Valid JSON Web Tokens (JWTs) for authentication within the RESTful API Proper middleware to verify users have the correct role for each operation in the API Prior Work This project picks up right where the last one left off, so if you haven’t completed that one yet, go back and do that before starting this one.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/index.xml" rel="self" type="application/rss+xml"/><item><title>Bypass Auth</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/01-bypass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/01-bypass/</guid><description>Authentication Libraries There are many different authentication libraries and methods available for Node.js and Express. For this project, we will use the Passport.js library. It supports many different authentication strategy, and is a very common way that authentication is handled within JavaScript applications.
For our application, we’ll end up using several strategies to authenticate our users:
Unique Token - used to bypass authentication for testing CAS - used to authenticate with Central Authentication Service (CAS) servers such as those used at K-State JSON Web Tokens (JWT) - used to identify user requests to the API itself Let’s first set up our unique token strategy, which allows us to test our authentication routes before setting up anything else.</description></item><item><title>Cookie Sessions</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/02-cookie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/02-cookie/</guid><description>Cookie Sessions One of the most common methods for keeping track of users after they are authenticated is by setting a cookie on their browser that is sent with each request. We’ve already explored this method earlier in this course, so let’s go ahead and configure cookie sessions for our application, storing them in our existing database.
We’ll start by installing both the express-session middleware and the connect-session-sequelize library that we can use to store our sessions in a Sequelize database:</description></item><item><title>JSON Web Token</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/03-jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/03-jwt/</guid><description>JSON Web Tokens (JWT) Now that we have a working authentication system, the next step is to configure a method to request a valid JSON Web Token, or JWT, that contains information about the authenticated user. We’ve already learned a bit about JWTs in this course, so we won’t cover too many of the details here.
To work with JWTs, we’ll need to install the jsonwebtoken package from NPM:</description></item><item><title>Auth Routing</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/04-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/04-routing/</guid><description>Routing after Authentication The last step we should take in our authentication system is to properly route users back to the index page after a successful login attempt. Since we will eventually be building a single-page application in Vue.js as our frontend for this application, we only need to worry about directing users back to the index page, which will load our frontend.
So, in our authSuccess method in routes/auth.</description></item><item><title>CAS Authentication</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/05-cas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/05-cas/</guid><description>CAS Authentication We’ve already studied Central Authentication Service (CAS) as one method for authenticating users through a third party service. In this case, CAS is the service commonly used at K-State for authentication, which is why we like to cover it in our examples. So, let’s look at how to add CAS authentication to our application through Passport.
Installing a Passport Strategy First, we’ll need to install a new Passport.</description></item><item><title>New Users</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/06-new-user/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/06-new-user/</guid><description>Handling New Users What if a user logs in to our application through CAS, but we don’t have them in our database of users? Do we want to deny them access to the application? Or should we somehow gracefully add them to the list of users and give them some basic access to our application?
Since we are building a website meant to be open to a number of users, let’s go ahead and implement a strategy where a new user can be created in the event that a user logs on through one of our authentication strategies but isn’t found in the database.</description></item><item><title>Testing Authentication</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/07-testing-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/07-testing-auth/</guid><description>Testing Authentication Routes Now that we have our authentication system working for our application, let’s write some unit tests to confirm that it works as expected in a variety of situations.
As part of these tests, we’ll end up creating a test double of one part of our authentication system to make it easier to test. To do this, we’ll use the Sinon library, so let’s start by installing it as a development dependency:</description></item><item><title>Role-Based Authorization</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/08-role-based/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/08-role-based/</guid><description>Token Middlewares Now that we finally have a working authentication system, we can start to add role-based authorization to our application. This will ensure that only users with specific roles can perform certain actions within our RESTful API. To do this, we’ll need to create a couple of new Express middlewares to help load the contents of our JWT into the request, and also to verify that the authenticated user has the appropriate roles to perform an action.</description></item><item><title>Updating Tests</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/09-updating-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/09-updating-tests/</guid><description>Updating Unit Tests Of course, now that we’re requiring a valid JWT for all API routes, and adding role-based authorization for most routes, all of our existing API unit tests now longer work. So, let’s work on updating those tests to use our new authentication system.
First, let’s build a simple helper function we can use to easily log in as a user and request a token to use in our application.</description></item><item><title>Testing Roles</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/10-testing-roles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/10-testing-roles/</guid><description>Testing Role-Based Authorization Middleware Earlier in this example we created a generator function named roleBasedAuth (stored in middlewares/authorized-roles.js) that returns a middleware function named roleAuthMiddleware that we can use as a middleware in any of our RESTful API endpoints to ensure that only users with specific roles are able to perform each and every action in our API.
When it comes to testing, however, this can quickly become really complex.</description></item><item><title>Users API Updates</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/11-user-updates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/04-authentication/11-user-updates/</guid><description>Users API Roles We should also add our role-based authorization middleware to our /api/v1/users routes. This can actually be done really simply, because we only want users with the manage_users role to be able to access any of these routes.
So, instead of attaching the middleware to each handler individually, we can attach it directly to the router before any handlers:
/** * @file Users router * @author Russell Feldhausen &lt;russfeld@ksu.</description></item></channel></rss>