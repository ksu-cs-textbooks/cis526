<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Adding a Database :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/index.html</link><description>This example project builds on the previous Express Starter Project by adding a database. A database is a powerful way to store and retrieve the data used by our web application.
To accomplish this, we’ll learn about different libraries that interface between our application and a database. Once we’ve installed a library, we’ll discover how to use that library to create database tables, add initial data to those tables, and then easily access them within our application.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/index.xml" rel="self" type="application/rss+xml"/><item><title>Sequelize</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/01-sequelize/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/01-sequelize/index.html</guid><description>Database Libraries To begin, we must first select a library to use when interfacing with our database. There are many different types of libraries, and many different options to choose from.
First and foremost, we can always just write raw SQL queries directly in our code. This is often very straightforward, but also can lead to very complex code and security issues. It also doesn’t offer many of the more advanced features such as mapping database results to object types and automatically managing database schemas.</description></item><item><title>Migrations</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/02-migrations/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/02-migrations/index.html</guid><description>Umzug Now that we have a database configured in our application, we need to create some way to actually populate that database with the tables and information our app requires. We could obviously do that manually, but that really makes it difficult (if not impossible) to automatically build, test, and deploy this application.</description></item><item><title>Seeds</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/03-seeds/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/03-seeds/index.html</guid><description>Database Seeding Another useful task that umzug can handle is adding some initial data to a new database. This process is known as seeding the database. Thankfully, the process for seeding is nearly identical to the process for migrations - in fact, it uses the same operations in different ways! So, let’s explore how to set that up.</description></item><item><title>Models</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/04-models/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/04-models/index.html</guid><description>Database Models Now that we have our database table structure and sample data set up, we can finally configure sequelize to query our database by defining a model representing that data. At its core, a model is simply an abstraction that represents the structure of the data in a table of our database. We can equate this to a class in object-oriented programming - each row or record in our database can be thought of as an instance of our model class. You can learn more about models in the Sequelize Documentation</description></item><item><title>Documenting Models</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/05-documenting/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/05-documenting/index.html</guid><description>Documenting Models with Open API Before we move ahead, let’s quickly take a minute to add some documentation to our models using the Open API specification. The details can be found in the Open API Specification Document
First, let’s update our configuration in the configs/openapi.js file to include the models directory:
​ configs/openapi.js // -=-=- other code omitted here -=-=- // Configure SwaggerJSDoc options const options = { definition: { openapi: "3.1.0", info: { title: "Example Project", version: "0.0.1", description: "Example Project", }, servers: [ { url: url(), }, ], }, apis: ["./routes/*.js", "./models/*.js"], }; // -=-=- other code omitted here -=-=- Next, at the top of our models/user.js file, we can add information in an @swagger tag about our newly created User model, usually placed right above the model definition itself:</description></item><item><title>Automation</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/06-automation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/06-automation/index.html</guid><description>Automating Database Deployment One very helpful feature we can add to our application is the ability to automatically migrate and seed the database when the application first starts. This can be especially helpful when deploying this application in a container.
To do this, let’s add some additional code to our bin/www file that is executed when our project starts:</description></item><item><title>Another Table</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/07-another-table/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/02-database/07-another-table/index.html</guid><description>Adding Another Table Now that we have a working database, let’s explore what it takes to add a new table to our application to represent additional models and data in our database.
We’ve already created a users table, which contains information about the users of our application. Now we want to add a roles table to contain all of the possible roles that our users can hold. In addition, we need some way to associate a user with a number of roles. Each user can have multiple roles, and each role can be assigned to multiple users. This is known as a many to many database relation, and requires an additional junction table to implement it properly. The end goal is to create the database schema represented in this diagram:</description></item></channel></rss>