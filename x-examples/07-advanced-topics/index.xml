<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Advanced Topics :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/</link><description>This example project builds on the previous Vue.js CRUD app by discussing some more advanced topics related to web application development.
Project Deliverables At the end of this example, we will have a project with the following features:
A Pinia store that handles storing users and roles, and all Vue components adapted to use that Pinia store A DynamicDialog for editing and creating users, which repurposes the UserEdit component A working Dockerfile for the project A working GitHub Action to build the Docker image and release it on GitHub A working Docker Compose file to deploy the application The application is adapted to optionally use Postgres instead of SQLite as the database engine Prior Work This project picks up right where the last one left off, so if you haven’t completed that one yet, go back and do that before starting this one.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/index.xml" rel="self" type="application/rss+xml"/><item><title>Pinia</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/01-pinia/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/01-pinia/</guid><description>Props So far, we’ve mostly been dealing with data in our Vue components in one of two ways:
It is requested directly from the RESTful API for the component (as in the UsersList and UserEdit components) It is passed in from a parent component, especially if it is a small helper component (as in the RoleChip and TextField components) The only exception is the user’s JSON Web Token (JWT), which we have stored in a Pinia store.</description></item><item><title>Reusing Components</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/02-reusing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/02-reusing/</guid><description>Reusing Components One of the many amazing features of a front-end framework such as Vue is the ability to reuse components in very powerful ways. For example, right now our application uses an entirely separate view and component to handle editing and updating users, but that means that we have to constantly jump back and forth between two views when working with users. Now that those views are using a shared Pinia store, we can use a PrimeVue DynamicDialog component to allow us to open the UserEdit component in a popup dialog on our UsersList component.</description></item><item><title>Preparing for Deployment</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/03-prep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/03-prep/</guid><description>Preparing for Deployment At this point, we have a pretty well developed application, so let’s start preparing for deployment. Our end goal is to build a single Docker container that contains our application, as well as the ability to deploy it along with a production database like Postgres.
To begin, we need to create a finalized version of our Vue frontend that can be embedded into our backend application directly.</description></item><item><title>Dockerfile</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/04-docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/04-docker/</guid><description>Dockerfile We are now ready to create a Dockerfile that will build our application into a single Docker container that can be easily deployed in a variety of different infrastructures. Because our application is really two parts (the server and the client), we can use a Multi-Stage Build in Docker to make a very streamlined version of our image.
Docker Init In this tutorial, we’ll go through building this Dockerfile manually.</description></item><item><title>GitHub Actions</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/05-github-actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/05-github-actions/</guid><description>GitHub Actions The last step in configuring our application for deployment is to create a GitHub Action that will automatically build our Docker container when we commit a release tag to GitHub. This process will ensure that our image is always up to date and available for users to download and use.
Learning how to build a GitHub Action script could be an entire course unto itself. For this project, we’ll run through the basic steps used to test and build our application’s Docker image, but there are many more steps that could be added.</description></item><item><title>Docker Compose</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/06-compose/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/06-compose/</guid><description>Docker Compose The last step we can take to make our application easier to deploy is to create a Docker Compose file that shows how to deploy this application easily within a Docker environment. It is becoming more and more popular for self-hosted projects and web applications to include a sample Docker Compose file to show how the application should be deployed in practice. So, let’s look at a quick example for our application.</description></item><item><title>External Database</title><link>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/07-external-db/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/x-examples/07-advanced-topics/07-external-db/</guid><description>Connecting to an External Database Finally, what if we’d like to update our application to connect to an external database? This could be very useful if we plan on using this application in production with a large amount of data, because an external database will be much faster and handle large amounts of data much better than our SQLite database stored in a single file.
For this example, we’ll update our application to be able to use Postgres.</description></item></channel></rss>