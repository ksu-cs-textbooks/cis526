<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Persistent Storage :: CIS 526 Textbook</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/index.html</link><description>Tupperware for the Web</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 06 Jul 2022 10:20:05 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/01-introduction/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/01-introduction/index.html</guid><description>Of course, what made dynamic web servers interesting was that they could provide content built dynamically. In this approach, the HTML the server sends as a response does not need to be stored on the server as a HTML file, rather it can be constructed when a request is made.
That said, most web applications still need a persistent storage mechanism to use in dynamically creating those pages. If we’re dealing with a forum, we need to store the text for the posts. If we’re running an e-commerce site, we aren’t making up products, we’re selling those already in our inventory.</description></item><item><title>Data Serialization</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/02-data-serialization/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/02-data-serialization/index.html</guid><description>Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:
const fs = require('fs'); /** @module database * A simple in-memory database implementation, * providing a mechanism for getting and saving * a database object */ module.exports = { get, set }; // We retrieve and deserialize the database from // a file named data.json. We deliberately don't // catch errors, as if this process fails, we want // to stop the server loading process var fileData = fs.readFileSync('data.json'); var data = JSON.parse(fileData); /** @function get() * Returns the database object * @returns {object} data - the data object */ function get() { return data; } /** @function set() * Saves the provided object as the database data, * overwriting the current object * @param {object} newData - the object to save * @param {function} callback - triggered after save */ function set(newData, callback) { // Here we don't want the server to crash on // an error, so we do wrap it in a try/catch try { var fileData = JSON.stringify(newData); fs.writeFile("data.json", fileData, (err) => { // If there was an error writing the data, we pass it // forward in the callback and don't save the changes // to the data object if(err) return callback(err); // If there was no error, we save the changes to the // module's data object (the variable data declared above) data = newData // Then we invoke the callback to notify of success by sending // a value of null for the error callback(null); }); } catch (err) { // If we catch an error in the JSON stringification process, // we'll pass it through the callback callback(err); } } In this module, we exploit a feature of Node’s require, in that it caches the value returned by the require() function for each unique argument. So the first time we use require('./database'), we process the above code. Node internally stores the result (an object with the get() and set() method) in its module cache, and the next time we use require('./database') in our program, this object is what is required. Effectively, you end up using the same data variable every time you require('./database'). This is an application of the Singleton Pattern in a form unique to Node.</description></item><item><title>Databases</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/03-databases/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/03-databases/index.html</guid><description>As we suggested in the previous section, using an already existing database application is a very common strategy for full-stack web development. Doing so has clear benefits - such programs are typically stable, secure, and optimized for data storage and retrieval. They are well beyond what we can achieve ourselves without a significant investment of time, and avoids the necessity of “reinventing the wheel”.
That said, making effective use of a third-party database system does require you to develop familiarity with how the database operates and is organized. Gaining the benefits of a database’s optimizations requires structuring your data in the way its developers anticipated, and likewise retrieving it in such a manner. The exact details involved vary between database systems and are beyond the scope of this course, which is why you have a database course in your required curriculum. Here I will just introduce the details of how to integrate the use of a database into your web development efforts, and I’ll leave the learning of how to best optimize your database structure and queries for that course.</description></item><item><title>Relational Databases</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/04-relational-databases/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/04-relational-databases/index.html</guid><description>Relational databases (also called SQL databases) provide a highly-structured storage mechanism. Data is organized into tables, with each column representing a single value and data type, and each row representing one entry. Conceptually, this organization is similar to tables you have seen in Excel and on the web. An example persons table is listed below:
id First Last 0 Lisa Merkowsky 1 Frank Stiles 3 Mary Cotts Relational databases are often called SQL databases as we use Structured Query Language (SQL) to communicate with them. This is a domain-specific language similar to the LINQ you may have learned about in CIS 400 (actually, LINQ derives much of its syntax from SQL). Queries are streamed to a relational database across a socket or other connection, much like HTTP requests and responses are. The response is received also as text which must be parsed to be used.</description></item><item><title>SQL Injection</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/05-sql-injection/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/05-sql-injection/index.html</guid><description>Along with the use of relational databases and SQL comes one very important attack to be aware of - SQL injection. This attack takes advantage of the way many developers write SQL queries within their programs. Consider the simple relational database we laid out earlier. Let’s assume our web application lets us search for people by their last names. To find Mary Cotts, we would then need a SQL query like:</description></item><item><title>Object-Relational Mapping</title><link>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/06-orm/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/06-orm/index.html</guid><description>If you think learning and writing SQL looks challenging, you’re not alone. Early full-stack developers did as well. In addition, there was the additional need to convert the responses from the relational database from text into objects the program could use. It shouldn’t be surprising that libraries quickly were adopted to manage this process. The most basic of these are drivers, simple programs which manage the connection between the database and the program using it, sending SQL queries to the database and parsing the results into data types native to the language (usually an array of arrays or an array of dictionaries - the outer array for the rows, and the inner array or dictionary for the column values within the row).</description></item></channel></rss>