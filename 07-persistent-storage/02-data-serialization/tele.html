<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:
const fs = require('fs'); /** @module database * A simple in-memory database implementation, * providing a mechanism for getting and saving * a database object */ module.exports = { get, set }; // We retrieve and deserialize the database from // a file named data.json. We deliberately don't // catch errors, as if this process fails, we want // to stop the server loading process var fileData = fs.readFileSync('data.json'); var data = JSON.parse(fileData); /** @function get() * Returns the database object * @returns {object} data - the data object */ function get() { return data; } /** @function set() * Saves the provided object as the database data, * overwriting the current object * @param {object} newData - the object to save * @param {function} callback - triggered after save */ function set(newData, callback) { // Here we don't want the server to crash on // an error, so we do wrap it in a try/catch try { var fileData = JSON.stringify(newData); fs.writeFile(&#34;data.json&#34;, fileData, (err) => { // If there was an error writing the data, we pass it // forward in the callback and don't save the changes // to the data object if(err) return callback(err); // If there was no error, we save the changes to the // module's data object (the variable data declared above) data = newData // Then we invoke the callback to notify of success by sending // a value of null for the error callback(null); }); } catch (err) { // If we catch an error in the JSON stringification process, // we'll pass it through the callback callback(err); } } In this module, we exploit a feature of Node’s require, in that it caches the value returned by the require() function for each unique argument. So the first time we use require('./database'), we process the above code. Node internally stores the result (an object with the get() and set() method) in its module cache, and the next time we use require('./database') in our program, this object is what is required. Effectively, you end up using the same data variable every time you require('./database'). This is an application of the Singleton Pattern in a form unique to Node."><meta name=author content="Nathan Bean & Russell Feldhausen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta name=twitter:title content="Data Serialization :: CIS 526 Textbook"><meta name=twitter:description content="Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:
const fs = require('fs'); /** @module database * A simple in-memory database implementation, * providing a mechanism for getting and saving * a database object */ module.exports = { get, set }; // We retrieve and deserialize the database from // a file named data.json. We deliberately don't // catch errors, as if this process fails, we want // to stop the server loading process var fileData = fs.readFileSync('data.json'); var data = JSON.parse(fileData); /** @function get() * Returns the database object * @returns {object} data - the data object */ function get() { return data; } /** @function set() * Saves the provided object as the database data, * overwriting the current object * @param {object} newData - the object to save * @param {function} callback - triggered after save */ function set(newData, callback) { // Here we don't want the server to crash on // an error, so we do wrap it in a try/catch try { var fileData = JSON.stringify(newData); fs.writeFile(&#34;data.json&#34;, fileData, (err) => { // If there was an error writing the data, we pass it // forward in the callback and don't save the changes // to the data object if(err) return callback(err); // If there was no error, we save the changes to the // module's data object (the variable data declared above) data = newData // Then we invoke the callback to notify of success by sending // a value of null for the error callback(null); }); } catch (err) { // If we catch an error in the JSON stringification process, // we'll pass it through the callback callback(err); } } In this module, we exploit a feature of Node’s require, in that it caches the value returned by the require() function for each unique argument. So the first time we use require('./database'), we process the above code. Node internally stores the result (an object with the get() and set() method) in its module cache, and the next time we use require('./database') in our program, this object is what is required. Effectively, you end up using the same data variable every time you require('./database'). This is an application of the Singleton Pattern in a form unique to Node."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/02-data-serialization/index.html"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Data Serialization :: CIS 526 Textbook"><meta property="og:description" content="Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:
const fs = require('fs'); /** @module database * A simple in-memory database implementation, * providing a mechanism for getting and saving * a database object */ module.exports = { get, set }; // We retrieve and deserialize the database from // a file named data.json. We deliberately don't // catch errors, as if this process fails, we want // to stop the server loading process var fileData = fs.readFileSync('data.json'); var data = JSON.parse(fileData); /** @function get() * Returns the database object * @returns {object} data - the data object */ function get() { return data; } /** @function set() * Saves the provided object as the database data, * overwriting the current object * @param {object} newData - the object to save * @param {function} callback - triggered after save */ function set(newData, callback) { // Here we don't want the server to crash on // an error, so we do wrap it in a try/catch try { var fileData = JSON.stringify(newData); fs.writeFile(&#34;data.json&#34;, fileData, (err) => { // If there was an error writing the data, we pass it // forward in the callback and don't save the changes // to the data object if(err) return callback(err); // If there was no error, we save the changes to the // module's data object (the variable data declared above) data = newData // Then we invoke the callback to notify of success by sending // a value of null for the error callback(null); }); } catch (err) { // If we catch an error in the JSON stringification process, // we'll pass it through the callback callback(err); } } In this module, we exploit a feature of Node’s require, in that it caches the value returned by the require() function for each unique argument. So the first time we use require('./database'), we process the above code. Node internally stores the result (an object with the get() and set() method) in its module cache, and the next time we use require('./database') in our program, this object is what is required. Effectively, you end up using the same data variable every time you require('./database'). This is an application of the Singleton Pattern in a form unique to Node."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Persistent Storage"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2021-07-01T15:48:20-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><meta itemprop=name content="Data Serialization :: CIS 526 Textbook"><meta itemprop=description content="Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:
const fs = require('fs'); /** @module database * A simple in-memory database implementation, * providing a mechanism for getting and saving * a database object */ module.exports = { get, set }; // We retrieve and deserialize the database from // a file named data.json. We deliberately don't // catch errors, as if this process fails, we want // to stop the server loading process var fileData = fs.readFileSync('data.json'); var data = JSON.parse(fileData); /** @function get() * Returns the database object * @returns {object} data - the data object */ function get() { return data; } /** @function set() * Saves the provided object as the database data, * overwriting the current object * @param {object} newData - the object to save * @param {function} callback - triggered after save */ function set(newData, callback) { // Here we don't want the server to crash on // an error, so we do wrap it in a try/catch try { var fileData = JSON.stringify(newData); fs.writeFile(&#34;data.json&#34;, fileData, (err) => { // If there was an error writing the data, we pass it // forward in the callback and don't save the changes // to the data object if(err) return callback(err); // If there was no error, we save the changes to the // module's data object (the variable data declared above) data = newData // Then we invoke the callback to notify of success by sending // a value of null for the error callback(null); }); } catch (err) { // If we catch an error in the JSON stringification process, // we'll pass it through the callback callback(err); } } In this module, we exploit a feature of Node’s require, in that it caches the value returned by the require() function for each unique argument. So the first time we use require('./database'), we process the above code. Node internally stores the result (an object with the get() and set() method) in its module cache, and the next time we use require('./database') in our program, this object is what is required. Effectively, you end up using the same data variable every time you require('./database'). This is an application of the Singleton Pattern in a form unique to Node."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2021-07-01T15:48:20-05:00"><meta itemprop=wordCount content="949"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis526/images/hero.png"><title>Data Serialization :: CIS 526 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis526/07-persistent-storage/02-data-serialization/index.html rel=canonical type=text/html title="Data Serialization :: CIS 526 Textbook"><link href=/cis526/07-persistent-storage/02-data-serialization/index.xml rel=alternate type=application/rss+xml title="Data Serialization :: CIS 526 Textbook"><link href=/cis526/07-persistent-storage/02-data-serialization/index.print.html rel=alternate type=text/html title="Data Serialization :: CIS 526 Textbook"><link href=/cis526/07-persistent-storage/02-data-serialization/embed.html rel=alternate type=text/html title="Data Serialization :: CIS 526 Textbook"><link href=/cis526/css/auto-complete/auto-complete.min.css?1753540871 rel=stylesheet><script src=/cis526/js/auto-complete/auto-complete.min.js?1753540871 defer></script><script src=/cis526/js/search-lunr.min.js?1753540871 defer></script><script src=/cis526/js/search.min.js?1753540871 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis526/searchindex.en.js?1753540871"</script><script src=/cis526/js/lunr/lunr.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.stemmer.support.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.multi.min.js?1753540871 defer></script><script src=/cis526/js/lunr/lunr.en.min.js?1753540871 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1753540871 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/fonts/fontawesome/css/fontawesome-all.min.css?1753540871 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar/perfect-scrollbar.min.css?1753540871 rel=stylesheet><link href=/cis526/css/theme.min.css?1753540871 rel=stylesheet><link href=/cis526/css/format-html.min.css?1753540871 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/07-persistent-storage/02-data-serialization/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis526/css/custom.css?1753540871 rel=stylesheet></head><body class="mobile-support html" data-url=/cis526/07-persistent-storage/02-data-serialization/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 07-persistent-storage" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=data-serialization>Data Serialization</h1><p>Perhaps the simplest persistent storage mechanism we can adopt is to use a combination of an in-memory variable and a file. For example, we could set up a simple database mechanism as a Node module:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;fs&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @module database 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * A simple in-memory database implementation, 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * providing a mechanism for getting and saving 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * a database object
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>get</span>, <span style=color:#a6e22e>set</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We retrieve and deserialize the database from 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// a file named data.json.  We deliberately don&#39;t 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// catch errors, as if this process fails, we want 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to stop the server loading process
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fileData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFileSync</span>(<span style=color:#e6db74>&#39;data.json&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>fileData</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @function get()
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns the database object 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @returns {object} data - the data object
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @function set()
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Saves the provided object as the database data, 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * overwriting the current object
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param {object} newData - the object to save 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param {function} callback - triggered after save 
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>newData</span>, <span style=color:#a6e22e>callback</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Here we don&#39;t want the server to crash on 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// an error, so we do wrap it in a try/catch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fileData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>newData</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>writeFile</span>(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#a6e22e>fileData</span>, (<span style=color:#a6e22e>err</span>) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If there was an error writing the data, we pass it 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// forward in the callback and don&#39;t save the changes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// to the data object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>err</span>) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If there was no error, we save the changes to the 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// module&#39;s data object (the variable data declared above)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newData</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Then we invoke the callback to notify of success by sending 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// a value of null for the error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>callback</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we catch an error in the JSON stringification process,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// we&#39;ll pass it through the callback 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>In this module, we exploit a feature of Node&rsquo;s <a href=https://nodejs.org/en/knowledge/getting-started/what-is-require/ rel=external target=_blank>require</a>, in that it <em>caches</em> the value returned by the <code>require()</code> function for each unique argument. So the first time we use <code>require('./database')</code>, we process the above code. Node internally stores the result (an object with the <code>get()</code> and <code>set()</code> method) in its module cache, and the next time we use <code>require('./database')</code> in our program, this object is what is required. Effectively, you end up using the same <code>data</code> variable every time you <code>require('./database')</code>. This is an application of the <a href=https://en.wikipedia.org/wiki/Singleton_pattern rel=external target=_blank>Singleton Pattern</a> in a form unique to Node.</p><h2 id=refactoring-for-better-error-prevention>Refactoring for Better Error Prevention</h2><p>While this module can work well, it does suffer from a number of limitations. Perhaps the most important to recognize is that the <code>get()</code> method returns a reference to our aforementioned <code>data</code> variable - so if you change the value of the variable, you change it for all future <code>get()</code> function calls, while sidestepping the persistent file write embodied in our <code>set()</code>. Instead of providing a reference, we could instead provide a copy. A simple trick to do so in JavaScript is to serialize and then deserialize the object (turning it into a JSON string and then back into an object). The refactored <code>get()</code> would then look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>/** @function get()
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns A COPY OF the database object 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @returns {object} data - A COPY OF the data object
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>data</span>));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Note that there is a possibility this process can fail, so it really should be wrapped in a <code>try/catch</code> and refactored to use a callback to pass on this possible error and the data object:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>/** @function get()
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Provides a copy of the data object
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param {function} callback - Provides as the first parameter any errors, 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * and as the second a copy of the data object.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>callback</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dataCopy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>data</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callback</span>(<span style=color:#66d9ef>null</span>, <span style=color:#a6e22e>dataCopy</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Notice that with this refactoring, we are using the same pattern common to the Node modules we&rsquo;ve been working with. There is a second benefit here is that if we needed to convert our <code>get()</code> from a synchronous to asynchronous implementation, our function definition won&rsquo;t change (the <code>set()</code> is already asynchronous, as we use the asynchronous <code>fs.writeFile()</code>).</p><h2 id=other-limitations>Other Limitations</h2><p>This database implementation is still pretty basic - we retrieve an entire object rather than just the portion of the database we need, and we write the entire database on every change as well. If our database gets to be very large, this will become an expensive operation.</p><p>There is also a lot of missed opportunity for optimizing how we get the specific data we need. As you have learned in your algorithms and data structures course, the right search algorithm, coupled with the right data structure, can vastly improve how quickly your program can run. If we think about the work that a webserver does, the retrieval of data for building dynamic HTML based on it is easily one of the most time-consuming aspects, so optimizing here can make each page creation move much faster. Faster page creation means shorter response times, and more users served per minute with less processing power. That, in turn means less electricity, less bandwidth, and less hardware is required to run your website. In heavily utilized websites, this can equate to a lot of savings! And for websites hosted on elastic hosting services (those that only charge for the resources you use), it can also result in significant savings.</p><p>Thus, we might want to spend more time developing a robust database program that would offer these kinds of optimizations. Or, we could do what most full-stack developers do, and use an already existing database program that was designed with these kinds of optimizations in mind. We&rsquo;ll take a look at that approach next.</p><footer class=footline></footer></article></div></main></div><script src=/cis526/js/clipboard/clipboard.min.js?1753540871 defer></script><script src=/cis526/js/perfect-scrollbar/perfect-scrollbar.min.js?1753540871 defer></script><script src=/cis526/js/theme.min.js?1753540871 defer></script></div><script src=/cis526/js/tele-scroll.min.js?1753540871 defer></script></body></html>