<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Etiquette for Web Servers and Clients"><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><meta name=twitter:description content="Etiquette for Web Servers and Clients"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis526/02-http/"><meta property="og:site_name" content="CIS 526 Textbook"><meta property="og:title" content="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><meta property="og:description" content="Etiquette for Web Servers and Clients"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><meta itemprop=description content="Etiquette for Web Servers and Clients"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T16:48:12-05:00"><meta itemprop=wordCount content="6"><title>Hyper-Text Transfer Protocol :: CIS 526 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis526/02-http/ rel=canonical type=text/html title="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><link href=/cis526/02-http/index.xml rel=alternate type=application/rss+xml title="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><link href=/cis526/02-http/tele.html rel=alternate type=text/html title="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><link href=/cis526/02-http/embed.html rel=alternate type=text/html title="Hyper-Text Transfer Protocol :: CIS 526 Textbook"><link href=/cis526/css/fontawesome-all.min.css?1738617099 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fontawesome-all.min.css?1738617099 rel=stylesheet></noscript><link href=/cis526/css/nucleus.css?1738617099 rel=stylesheet><link href=/cis526/css/auto-complete.css?1738617099 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/auto-complete.css?1738617099 rel=stylesheet></noscript><link href=/cis526/css/perfect-scrollbar.min.css?1738617099 rel=stylesheet><link href=/cis526/css/fonts.css?1738617099 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis526/css/fonts.css?1738617099 rel=stylesheet></noscript><link href=/cis526/css/theme.css?1738617099 rel=stylesheet><link href=/cis526/css/theme-auto.css?1738617099 rel=stylesheet id=R-variant-style><link href=/cis526/css/chroma-auto.css?1738617099 rel=stylesheet id=R-variant-chroma-style><link href=/cis526/css/variant.css?1738617099 rel=stylesheet><link href=/cis526/css/print.css?1738617099 rel=stylesheet media=print><link href=/cis526/css/format-print.css?1738617099 rel=stylesheet><script src=/cis526/js/variant.js?1738617099></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis526",window.index_js_url="/cis526/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis526/css/custom.css?1738617099 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis526/02-http/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Hyper-Text Transfer Protocol</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis526/01-the-dom/07-summary/ title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis526/02-http/01-introduction/ title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 2</div><h1 id=hyper-text-transfer-protocol>Hyper-Text Transfer Protocol</h1><p>Etiquette for Web Servers and Clients</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Hyper-Text Transfer Protocol</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>At the heart of the world wide web is the Hyper-Text Transfer Protocol (HTTP). This is a protocol defining how HTTP servers (which host web pages) interact with HTTP clients (which display web pages).</p><p>It starts with a request initiated from the web browser (the client). This request is sent over the Internet using the TCP protocol to a web server. Once the web server receives the request, it must decide the appropriate response - ideally sending the requested resource back to the browser to be displayed. The following diagram displays this typical request-response pattern.</p><p><a href=#R-image-7c9de3ef699b5bdff034f9eb3793f187 class=lightbox-link><img alt="HTTP&rsquo;s request-response pattern" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.0.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-7c9de3ef699b5bdff034f9eb3793f187><img alt="HTTP&rsquo;s request-response pattern" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.0.1.png></a></p><p>This HTTP request-response pattern is at the core of how all web applications communicate. Even those that use websockets begin with an HTTP request.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The HTTP standard, along with many other web technologies, is maintained by the <a href=https://www.w3.org/ rel=external target=_blank>World-Wide-Web Consortium</a> (abbreviated W3C), stakeholders who create and maintain web standards. The full description of the Hyper-Text Transfer Protocol can be found here <a href=https://www.w3.org/Protocols/ rel=external target=_blank>w3c&rsquo;s protocols page</a>.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=browser-requests>Browser Requests</h1><p>Before we get too deep in the details of what a request is, and how it works, let&rsquo;s explore the primary kind of request you&rsquo;re already used to making - requests originating from a browser. Every time you use a browser to browse the Internet, you are creating a series of HTTP (or HTTPS) requests that travel across the networks between you and a web server, which responds to your requests.</p><p>To help illustrate how these requests are made, we&rsquo;ll once again turn to our developer tools. Open the example page <a href=/cis526/02-http/02-browser-requests/../../examples/2.2.1/index.html target=_blank>this link</a>. On that tab, open your developer tools with <code>CTRL + SHIFT + i</code> or by right-clicking the page and selecting &ldquo;Inspect&rdquo; from the context menu. Then choose the &ldquo;Network&rdquo; tab:</p><p><a href=#R-image-a9945dec82230a0cc33e2f08fb041a13 class=lightbox-link><img alt="Selecting the network tab in the developer tools" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.2.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a9945dec82230a0cc33e2f08fb041a13><img alt="Selecting the network tab in the developer tools" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.2.1.png></a></p><p>The network tab displays details about each request the browser makes. Initially it will probably be empty, as it does not log requests while not open. Try refreshing the page - you should see it populate with information:</p><p><a href=#R-image-1be9c9cd34ee003f79930728bdbcfff4 class=lightbox-link><img alt="The populated network tab" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.2.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-1be9c9cd34ee003f79930728bdbcfff4><img alt="The populated network tab" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.2.2.png></a></p><p>The first entry is the page itself - the HTML file. But then you should see entries for <em>site.css</em>, <em>brazil.gif</em>, <em>fiber-4814456_960_720.jpg</em>, <em>jquery-3.5.1.slim.min.js</em>, and <em>site.js</em>. Each of these entries represents an additional resource the browser fetched from the web in order to display the page.</p><p>Take, for example, the two images <em>brazil.gif</em> and <em>fiber-4814456_960_720.jpg</em>. These correspond to <code>&lt;img></code> tags in the HTML file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>alt</span><span class=o>=</span><span class=s>&#34;Paper scene from the film Brazil&#34;</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;brazil.gif&#34;</span><span class=p>/&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>alt</span><span class=o>=</span><span class=s>&#34;Fiber optic cables&#34;</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://cdn.pixabay.com/photo/2020/02/03/00/12/fiber-4814456_960_720.jpg&#34;</span><span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>        </span></span></code></pre></div><p>The important takeaway here is that the image is requested <em>separately</em> from the HTML file. As the browser reads the page and encounters the <code>&lt;img></code> tag, it makes an additional request for the resource supplied in its <code>src</code> attribute. When that second request finishes, the downloaded image is added to the web page.</p><p>Notice too that while one image was on our webserver, the other is retrieved from <a href=https://pixabay.com rel=external target=_blank>Pixabay.com</a>&rsquo;s server.</p><p>Similarly, we have two JavaScript files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://code.jquery.com/jquery-3.5.1.slim.min.js&#34;</span> <span class=na>integrity</span><span class=o>=</span><span class=s>&#34;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&#34;</span> <span class=na>crossorigin</span><span class=o>=</span><span class=s>&#34;anonymous&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;site.js&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span></span></span></code></pre></div><p>As with the images, one is hosted on our website, <em>site.js</em>, and one is hosted on another server, <a href=https://code.jquery.com/jquery-3.5.1.slim.min.js rel=external target=_blank>jquery.com</a>.</p><p>Both the Pixabay image and the jQuery library are hosted by a <a href=https://en.wikipedia.org/wiki/Content_delivery_network rel=external target=_blank>Content Delivery Network</a>- a network of proxy servers that are distributed geographically in such a way that a request for a resource they hold can be processed from a nearby server. Remember that the theoretical maximum speed for internet transmissions is the speed of light (for fiber optics) or electrons in copper wiring. Communication is further slowed at each network switch encountered. Serving files from a nearby server can prove very efficient at speeding up page loads because of the shorter distance and smaller number of switches involved.</p><p>A second benefit of using a CDN to request the JQuery library is that if the browser has previously downloaded the library when visiting another site it will have cached it. Using the cached version instead of making a new request is <em>much</em> faster. Your app will benefit by faster page loads that use less bandwidth.</p><p>Notice too that the jQuery <code>&lt;script></code> element also uses the <code>integrity</code> attribute to allow the browser to determine if the library downloaded was tampered with by comparing cryptographic tokens. This is an application of <a href=https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity rel=external target=_blank>Subresource Integrity</a>, a feature that helps protect your users. As JavaScript can transform the DOM, there are incentives for malicious agents to supplant real libraries with fakes that abuse this power. As a web developer you should be aware of this, and use all the tools at your disposal to keep your users safe.</p><p>You can use the network tab to help debug issues with resources. Click on one of the requested resources, and it will open up details about the request:</p><p><a href=#R-image-fc372ffad77525cd5a7de89e74d4d056 class=lightbox-link><img alt="Request details in the Network Tab" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.2.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-fc372ffad77525cd5a7de89e74d4d056><img alt="Request details in the Network Tab" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.2.3.png></a></p><p>Notice that it reports the status code along with details about the request and response, and provides a preview of the requested resource. We&rsquo;ll cover what these all are over the remainder of this chapter. As you learn about each topic, you may want to revisit the tab with the example to see how these details correspond to what you are learning.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=request-format>Request Format</h1><p>So now that we&rsquo;ve seen HTTP Requests in action, let&rsquo;s examine what they <em>are</em>. A HTTP Request is just a stream of text that follows a specific format and sent from a client to a server.</p><p><a href=#R-image-ffd1b4d6642be746a8753698bcc537ca class=lightbox-link><img alt="Http Request as a stream of text" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.3.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ffd1b4d6642be746a8753698bcc537ca><img alt="Http Request as a stream of text" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.3.1.png></a></p><p>It consists of one or more lines terminated by a CRLF (a carriage return and a line feed character, typically written <code>\r\n</code> in most programming languages).</p><ol><li>A <em>request-line</em> describing the request</li><li>Additional optional lines containing HTTP headers. These specify details of the request or describe the body of the request</li><li>A blank line, which indicates the end of the request headers</li><li>An optional body, containing any data belonging of the request, like a file upload or form submission. The exact nature of the body is described by the headers.</li></ol><h2 id=the-request-line>The Request-Line</h2><p>The request-line follows the format</p><p><code>Request-Line = Method SP Request-URI SP HTTP-Version CRLF</code></p><p>The <em>Method</em> refers to the HTTP Request Method (often GET or POST).</p><p><em>SP</em> refers to the space character.</p><p>The <em>Request-URI</em> is a Universal Request Indicator, and is typically a URL or can be the asterisk character (*), which refers to the server instead of a specific resource.</p><p><em>HTTP-Version</em> refers to the version of the HTTP protocol that will be used for the request. Currently three versions of the protocol exist: <code>HTTP/1.0</code>, <code>HTTP/1.1</code>, and <code>HTTP/2.0</code>. Most websites currently use HTTP/1.1 (HTTP/2.0 introduces many changes to make HTTP more efficient, at the cost of human readability. Currently it is primarily used by high-traffic websites).</p><p>Finally, the <em>CRLF</em> indicates a carriage return followed by a line feed.</p><p>For example, if we were requesting the about.html page of a server, the request-line string would be:</p><p><code>GET /about.html HTTP/1.1\r\n</code></p><h2 id=the-headers>The Headers</h2><p>Header lines consist of key-value pairs, typically in the form</p><p><code>Header = Key: Value CRLF</code></p><p>Headers provide details about the request, for example, if we wanted to specify we can handle the <em>about.html</em> page data compressed with the gzip algorithm, we would add the header:</p><p><code>Accept-Encoding: compress, gzip\r\n</code></p><p>The server would then know it could send us a zipped version of the file, resulting in less data being sent from the server to the client.</p><p>If our request includes a body (often form data or a file upload), we need to specify what that upload data is with a Content-Type header and its size with a Content-Length header, i.e.:</p><p><code>Content-Length: 26012 Content-Type: image/gif</code></p><h2 id=a-blank-line>A Blank Line</h2><p>The header section is followed by a blank line (a CRLF with no characters before it). This helps separate the request metadata from the request body.</p><h2 id=the-request-body>The Request Body</h2><p>The body of the request can be text (as is the case for most forms) or binary data (as in an image upload). This is why the Content-Type header is so important for requests with a body; it lets the server know how to process the data. Similarly, the Content-Length header lets us know how many bytes to expect the body to consist of.</p><p>It is also acceptable to have no body - this is commonly the case with a GET request. If there is no body, then there are also no required headers. A simple get request can therefore consist of only the request-line and blank line, i.e.:</p><p><code>GET /about.html HTTP/1.1\r\n\r\n</code></p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The HTTP/1.1 request definition can be found in <a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5 rel=external target=_blank>W3C RFC 2616 Section 5</a></p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=request-methods>Request Methods</h1><p>The first line of the HTTP request includes the <strong>request method</strong>, which indicates what kind of action the request is making of the web server (these methods are also known as <strong>HTTP Verbs</strong>). The two most common are <em>GET</em> and <em>POST</em>, as these are supported by most browsers.</p><h3 id=commonly-used-http-methods>Commonly Used HTTP Methods</h3><p>The following requests are those most commonly used in web development. As noted before GET and POST requests are the most commonly used by web browsers, while GET, PUT, PATCH, and DELETE are used by RESTful APIs. Finally, HEAD can be used to optimize web communications by minimizing unnecessary data transfers.</p><h4 id=get>GET</h4><p>A <em>GET</em> request seeks to retrieve a specific resource from the web server - often an HTML document or binary file. GET requests typically have no body and are simply used to retrieve data. If the request is successful, the response will typically provide the requested resource in its body.</p><h4 id=head>HEAD</h4><p>A <em>HEAD</em> request is similar to a GET request, except the response is not expected to provide a body. This can be used to verify the type of content of the resource, the size of the resource, or other metadata provided in the response header, without downloading the full data of the resource.</p><h4 id=post>POST</h4><p>The <em>POST</em> request submits an entity to the resource, i.e. uploading a file or form data. It typically will have a body, which is the upload or form.</p><h4 id=put>PUT</h4><p>The <em>PUT</em> request is similar to a POST request, in that it submits an entity as its body. It has a more strict semantic meaning though; a PUT request is intended to <em>replace</em> the specified resource in its entirety.</p><h4 id=patch>PATCH</h4><p>The <em>PATCH</em> request is also similar to POST and PUT requests - it submits an entity as its body. However, its semantic meaning is to only apply partial modifications to the specified entity.</p><h4 id=delete>DELETE</h4><p>As you might expect, the DELETE method is used to delete the specified resource from the server.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>Additional methods include <em>CONNECT</em>, which establishes a tunnel to a server; <em>OPTIONS</em>, which identifies communications options with a resource, and <em>TRACE</em>, which performs a message loop-back test to the target resource. HTTP Methods are defined in <a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html rel=external target=_blank>W3C&rsquo;s RFC2616</a>.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=uris-and-urls>URIs and URLs</h1><p>Before a web request can be made, the browser needs to know where the resource requested can be found. This is the role that a Universal Resource Locator (a URL) plays. A URL is a specific kind of Universal Resource Indicator (URI) that specifies how a specific resource can be retrieved.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p><strong>URLs and URIs</strong>
The terms URL and URI are often used interchangeably in practice. However, a URL is a specific subset of URIs that indicate <em>how to retrieve a resource over a network</em>; while a URI identifies a unique resource, it does not necessarily indicate how to retrieve it. For example, a book&rsquo;s ISBN can be represented as a URI in the form <em>urn:isbn:0130224189</em>. But this URI cannot be put into a browser&rsquo;s Location to retrieve the associated book.</p></div></div><p>A URI consists of several parts, according to the definition (elements in brackets are optional):</p><p><code>URI = scheme:[//[userinfo@]host[:port]]path[?query][#fragment]</code></p><p>Let&rsquo;s break this down into individual parts:</p><p><strong>scheme:</strong> The scheme refers to the resource is identified and (potentially) accessed. For web development, the primary schemes we deal with are <em>http</em> (hyper-text transfer protocol), <em>https</em> (secure hyper-text transfer protocol), and <em>file</em> (indicating a file opened from the local computer).</p><p><strong>userinfo:</strong> The userinfo is used to identify a specific user. It consists of a username optionally followed by a colon (<code>:</code>) and password. We will discuss its use in the section on HTTP authentication, but note that this approach is rarely used today, and carries potential security risks.</p><p><strong>host:</strong> The host consists of either a fully quantified domain name (i.e. google.com, cs.ksu.edu, or gdc.ksu.edu) or an ip address (i.e. <code>172.217.1.142</code> or <code>[2607:f8b0:4004:803::200e]</code>). IPv4 addresses <em>must</em> be separated by periods, and IPv6 addresses must be closed in brackets. Additionally, web developers will often use the loopback host, <code>localhost</code>, which refers to the local machine rather than a location on the network.</p><p><strong>port:</strong> The port refers to the port number on the host machine. If it is not specified (which is typical), the default port for the scheme is assumed: port 80 for HTTP, and port 443 for HTTPS.</p><p><strong>path:</strong> The path refers to the path to the desired resource on the server. It consists of segments separated by forward slashes (<code>/</code>).</p><p><strong>query:</strong> The query consists of optional collection of key-value pairs (expressed as key:value), separated by ampersands (<code>&</code>), and preceded by a question mark (<code>?</code>). The query string is used to supply modifiers to the requested resource (for example, applying a filter or searching for a term).</p><p><strong>fragment:</strong> The fragment is an optional string proceeded by a hashtag (<code>#</code>). It identifies a portion of the resource to retrieve. It is most often used to auto-scroll to a section of an HTML document, and also for navigation in some single-page web applications.</p><p>Thus, the URL <code>https://google.com</code> indicates we want to use the secure HTTP scheme to access the server at google.com using its port 443. This should retrieve Google&rsquo;s main page.</p><p>Similarly, the url <code>https://google.com/search?q=HTML</code> will open a Google search result page for the term HTML (Google uses the key <code>q</code> to identify search terms).</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=request-headers>Request Headers</h1><p>Request headers take the form of key-value pairs, separated by colons <code>:</code> and terminated with a CRLF (a carriage return and line feed character). For example:</p><div class=highlight><pre tabindex=0><code>Accept-Encoding: gzip</code></pre></div><p>Indicates that the browser knows how to accept content compressed in the <a href=https://en.wikipedia.org/wiki/Gzip rel=external target=_blank>Gzip format</a>.</p><p>Note that request headers are a subset of <em>message headers</em> that apply specifically to requests. There are also message headers that apply only to HTTP responses, and some that apply to both.</p><p>As HTTP is intended as an extensible protocol, there are a <em>lot</em> of potential headers. IANA maintains the <a href=https://www.iana.org/assignments/message-headers/message-headers.xhtml rel=external target=_blank>official list of message headers</a> as well as <a href=https://www.iana.org/assignments/message-headers/message-headers.xhtml rel=external target=_blank>a list of proposed message headers</a>. You can also find a categorized list in the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers rel=external target=_blank>MDN Documentation</a></p><p>While there are many possible request headers, some of the more commonly used are:</p><p><strong>Accept</strong> Specifies the types a server can send back, its value is a MIME type.</p><p><strong>Accept-Charset</strong> Specifies the character set a browser understands.</p><p><strong>Accept-Encoding</strong> Informs the server about encoding algorithms the client can process (most typically compression types)</p><p><strong>Accept-Language</strong> Hints to the server what language content should be sent in.</p><p><strong>Authorization</strong> Supplies credentials to authenticate the user to the server. Will be covered in the authentication chapter.</p><p><strong>Content-Length</strong> The length of the request body sent, in octets</p><p><strong>Content-Type</strong> The MIME type of the request body</p><p><strong>Content-Encoding</strong> The encoding method of the request body</p><p><strong>Cookie</strong> Sends a site cookie - see the section on cookies later</p><p><strong>User-Agent</strong> A string identifying the agent making the request (typically a browser name and version)</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=request-body>Request Body</h1><p>After the request headers and an extra CRLF (carriage return and line feed) is the request body.</p><p>For GET and DELETE requests, there is no body. For POST, PUT, and PATCH, however, this section should contain the data being sent to the server. If there is a body, the headers should include <code>Content-Type</code> and <code>Content-Length</code>. The <code>Content-Length</code> is always provided as a count of <a href=https://en.wikipedia.org/wiki/Octet_(computing) rel=external target=_blank>octets</a> (a set of eight bits). Thus, binary data is sent as an <em>octet stream</em>. Text data is typically sent in <a href=https://en.wikipedia.org/wiki/UTF-8 rel=external target=_blank>UTF-8 encoding</a>.</p><p>Two body formats bear special mention: <code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code>. These encodings are commonly used for submitting HTML forms, and will be covered in more detail in the Form Data chapter.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=response-format>Response Format</h1><p>Similar to an HTTP Request, an HTTP response is typically a stream of text and possibly data:</p><p><a href=#R-image-f294b9a7f759bb2adf044d28900e00e4 class=lightbox-link><img alt="HTTP Response as a stream of text and data" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.8.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f294b9a7f759bb2adf044d28900e00e4><img alt="HTTP Response as a stream of text and data" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.8.1.png></a></p><p>It consists of one or more lines of text, terminated by a CRLF (sequential carriage return and line feed characters):</p><ol><li>A <em>status-line</em> indicating the HTTP protocol, the status code, and a textual status</li><li>Optional lines containing the Response Headers. These specify the details of the response or describe the response body</li><li>A blank line, indicating the end of the response metadata</li><li>An optional response body. This will typically be the text of an HTML file, or binary data for an image or other file type, or a block of bytes for streaming data.</li></ol><h2 id=the-status-line>The Status-Line</h2><p>The status-line follows the format</p><p><code>Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</code></p><p>The <em>HTTP-Version</em> indicates the version of the HTTP protocol that is being used (HTTP/1.0, HTTP/1.1, or HTTP/2.0).</p><p><em>SP</em> refers to a space character.</p><p>The <em>Status-Code</em> is a three-digit numeric representation of the response status. Common codes include 200 (OK), 404 (Not Found), and 500 (Server Error).</p><p>The <em>Reason-Phrase</em> is a plain-text explanation of the status code.</p><h2 id=response-headers>Response Headers</h2><p>Just like HTTP Requests, a HTTP response can contain headers describing the response. If the response has a body, a Content-Type and Content-Length header would be expected.</p><h2 id=a-blank-line>A Blank Line</h2><p>The header section is followed by a blank line (a CRLF with no characters before it). This helps separate the response metadata from the response body.</p><h2 id=response-body>Response Body</h2><p>The response body contains the data of the response. it might be text (as is typically the case with HTML, CSS, or JavaScript), or a binary file (an image, video, or executable). Additionally, it might only be a sequence of bytes, as is the case for streaming media.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>The full HTTP/1.1 response definition can be found in <a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6 rel=external target=_blank>W3C RFC 2616 Section 6</a>.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=status-codes>Status Codes</h1><p>The <em>status-line</em> consists of a numeric code, followed by a space, and then a human-readable status message that goes with the code. The codes themselves are 3-digit numbers, with the first number indicating a general category the response status falls into. Essentially, the status code indicates that the request is being fulfilled, or the reason it cannot be.</p><h3 id=1xx-status-codes>1XX Status Codes</h3><p>Codes falling in the 100&rsquo;s provide some kind of information, often in response to a <code>HEAD</code> or upgrade request. See the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status rel=external target=_blank>MDN Documentation</a> for a full list.</p><h3 id=2xx-status-codes>2XX Status Codes</h3><p>Codes in the 200&rsquo;s indicate success in some form. These include:</p><p><strong><code>200 OK</code></strong> A status of 200 indicates the request was successful. This is by far the most common response.</p><p><strong><code>201 Created</code></strong> Issued in response to a successful POST request, indicates the resource POSTed to the server has been created.</p><p><strong><code>202 Accepted</code></strong> Indicates the request was received but not yet acted upon. This is used for batch-style processes. An example you may be familiar with is submitting a DARS report request - the DARS server, upon receiving one, adds it to a list of reports to process and then sends a <code>202</code> response indicating it was added to the list, and should be available at some future point.</p><p>There are additional 200 status codes. See the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status rel=external target=_blank>MDN Documentation</a> for a full list.</p><h3 id=3xx-status-codes>3XX Status Codes</h3><p>Codes in the 300&rsquo;s indicate redirects. These should be used in conjunction with a <code>Location</code> response header to notify the user-agent where to redirect. The three most common are:</p><p><strong><code>301 Moved Permanently</code></strong> Indicates the requested resource is now permanently available at a different URI. The new URI should be provided in the response, and the user-agent may want to update bookmarks and caches.</p><p><strong><code>302 Found</code></strong> Also redirects the user to a different URI, but this redirect should be considered temporary and the original URI used for further requests.</p><p><strong><code>304 Not Modified</code></strong> Indicates the requested resource has not changed, and therefore the user-agent can use its cached version. By sending a 304, the server does not need to send a potentially large resource and consume unnecessary bandwidth.</p><p>There are additional 300 status codes. See the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status rel=external target=_blank>MDN Documentation</a> for a full list.</p><h3 id=4xx-status-codes>4XX Status Codes</h3><p>Codes in the 400&rsquo;s indicate client errors. These center around badly formatted requests and authentication status.</p><p><strong><code>400 Bad Request</code></strong> is a request that is poorly formatted and cannot be understood.</p><p><strong><code>401 Unauthorized</code></strong> means the user has not been authenticated, and needs to log in.</p><p><strong><code>403 Forbidden</code></strong> means the user does not have permissions to access the requested resource.</p><p><strong><code>404 Not Found</code></strong> means the requested resource is not found on the server.</p><p>There are <em>many</em> additional 400 status codes. See the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status rel=external target=_blank>MDN Documentation</a> for a full list.</p><h3 id=5xx-status-codes>5XX Status Codes</h3><p>Status codes in the 500&rsquo;s indicate server errors.</p><p><strong><code>500 Server Error</code></strong> is a generic code for &ldquo;something went wrong in the server.&rdquo;</p><p><strong><code>501 Not Implemented</code></strong> indicates the server does not know how to handle the request method.</p><p><strong><code>503 Service Unavailable</code></strong> indicates the server is not able to handle the request at the moment due to being down, overloaded, or some other temporary condition.</p><p>There are additional 500 status codes. See the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status rel=external target=_blank>MDN Documentation</a> for a full list.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=response-headers>Response Headers</h1><p>Response headers take the form of key-value pairs, separated by colons <code>:</code> and terminated with a CRLF (a carriage return and line feed character), just like Request Headers (both are types of Message Headers). For example, this header:</p><div class=highlight><pre tabindex=0><code>Expires: Wed, 12 Jun 2019 08:00:00 CST</code></pre></div><p>indicates to the browser that this content will expire June 12, 2019 at 8AM Central Standard Time. The browser can use this value when populating its cache, allowing it to use the cached version until the expiration time, reducing the need to make requests.</p><p>Note that response headers are a subset of <em>message headers</em> that apply specifically to requests. As we&rsquo;ve seen there are also message headers that apply only to HTTP requests, and some that apply to both.</p><p>As HTTP is intended as an extensible protocol, there are a <em>lot</em> of potential headers. IANA maintains the <a href=https://www.iana.org/assignments/message-headers/message-headers.xhtml rel=external target=_blank>official list of message headers</a> as well as <a href=https://www.iana.org/assignments/message-headers/message-headers.xhtml rel=external target=_blank>a list of proposed message headers</a>. You can also find a categorized list in the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers rel=external target=_blank>MDN Documentation</a></p><p>While there are many possible response headers, some of the more commonly used are:</p><p><strong>Allow</strong> Lists the HTTP Methods that can be used with the server</p><p><strong>Content-Length</strong> The length of the response body sent, in octets</p><p><strong>Content-Type</strong> The MIME type of the response body</p><p><strong>Content-Encoding</strong> The encoding method of the response body</p><p><strong>Location</strong> Used in conjunction with redirects (a 301 or 302 status code) to indicate where the user-agent should be redirected to.</p><p><strong>Server</strong> Contains information about the server handling the request.</p><p><strong>Set-Cookie</strong> Sets a cookie for this server on the client. The client will send back the cookie on subsequent requests using the <code>Cookie</code> header.</p><p>We&rsquo;ll make use of these headers as we start writing web servers.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=response-body>Response Body</h1><p>After the response headers and an extra CRLF (carriage return and line feed) is the response body.</p><p>The body is typically text (for HTML, CSS, JavaScript, and other text files) or binary data (for images, video, and other file types).</p><p>Setting the <code>Content-Type</code> and <code>Content-Length</code> headers lets the web client know what kind of data, and how much of it, should be expected. If these headers are not supplied in the response, the browser may treat the body as a blob of binary data, and only offer to save it.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=http-20>HTTP 2.0</h1><p>You may have noticed that the earlier parts of this chapter focused on HTTP version 1.1, while mentioning version 2.0. You might wonder why we didn&rsquo;t instead look at version 2.0 - and it&rsquo;s a valid question.</p><p>In short, HTTP 2.0 was created to make the request-response pattern of the web more efficient. One method it uses to do so is switching from text-based representations of requests and responses to binary-based representations. As you probably remember from working with File I/O, binary files are much smaller than the equivalent text file. The same is true of HTTP requests and responses. But the structure of HTTP 2.0 Requests and Responses are identical to HTTP 1.1 - they are simply binary (an hence, harder to read).</p><p>But this is not the only improvement in HTTP 2.0. Consider the request-response pattern we discussed earlier in the chapter:</p><p><a href=#R-image-e46004641114cae72b7b573b8dd86a3c class=lightbox-link><img alt="HTTP 2.0&rsquo;s request-response pattern" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.11.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e46004641114cae72b7b573b8dd86a3c><img alt="HTTP 2.0&rsquo;s request-response pattern" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.11.1.png></a></p><p>To display a webpage, the browser must first request the page&rsquo;s HTML data. As it processes the returned HTML, it will likely encounter HTML <code>&lt;img></code>, <code>&lt;link></code>, and <code>&lt;src></code> tags that refer to other resources on the server. To get these resources, it will need to make additional requests. For a modern webpage, this can add up quickly! Consider a page with 20 images, 3 CSS files, and 2 JavaScript files. That&rsquo;s 25 separate requests!</p><p>One of the big improvements between HTTP/1.0 and HTTP/1.1 was that HTTP/1.1 does not close its connection to the server immediately - it leaves a channel open for a few seconds. This allows it to request these additional files without needing to re-open the connection between the browser and the server.</p><p>HTTP/2.0 takes this thought a step farther, by trying to anticipate the browser&rsquo;s additional requests. In the HTTP/2.0 protocol, when a browser requests an HTML page, the server can <em>push</em> the additional, linked files as part of the response. Thus, the entire page content can be retrieved with a single request instead of multiple, separate requests. This minimizes network traffic, allowing the server to handle more requests, and speeds up the process of rendering pages on a client&rsquo;s machine.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=statelessness-and-scaling>Statelessness and Scaling</h1><p>One final point to make about Hyper-Text Transfer Protocol. It is a <em>stateless</em> protocol. What this means is that the server does not need to keep track of previous requests - each request is treated as though it was the first time a request has been made.</p><p>This approach is important for several reasons. One, if a server must keep track of previous requests, the amount of memory required would grow quickly, especially for popular web sites. We could very quickly grow past the memory capacity of the server hardware, causing the webserver to crash.</p><p><a href=#R-image-57d40cfea889ceeb2bc677c8951cf56a class=lightbox-link><img alt="Scaling strategies" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis526/images/2.12.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-57d40cfea889ceeb2bc677c8951cf56a><img alt="Scaling strategies" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis526/images/2.12.1.png></a></p><p>A second important reason is how we <em>scale</em> web applications to handle more visitors. We can do <em>vertical scaling</em> - increasing the power of the server hardware - or <em>horizontal scaling</em> - adding additional servers to handle incoming requests. Not surprisingly, the second option is the most cost-effective. But for it to work, requests need to be handed quickly to the first available server - there is no room for making sure a subsequent request is routed to the same server.</p><p>Thus, HTTP was designed as a <em>stateless</em> protocol, in that each new HTTP request is treated as being completely independent from all previous requests from the same client. This means that when using horizontal scaling, if the first request from client BOB is processed by server NANCY, and the second request from BOB is processed by server MARGE, there is no need for MARGE to know how NANCY responded. This stateless property was critical to making the world-wide-web even possible with the earliest internet technologies.</p><p>Of course, you probably have experience with websites that <em>do</em> seem to keep track of state - i.e. online stores, Canvas, etc. One of the challenges of the modern web was building state on top of a stateless protocol; we&rsquo;ll discuss the strategies used to do so in later chapters.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>In this chapter, we explored the Hyper-Text Transfer Protocol (HTTP), the technology used to exchange data across the web. We saw how requests and responses are simply well-structured streams of text or data exchanged across a packet-switched network. We examined the structure of these requests, and saw how they all use a similar pattern of a request or response line, a series of headers carrying metadata about the request or response, and an optional body.</p><p>We also discussed HTTP request methods like GET and POST, and HTTP response codes like a 404 and what these terms mean. We explored how HTTP has evolved from HTTP 1.0 to 1.1 to 2.0. And we discussed how HTTP is a stateless protocol, and how that statelessness is key to making websites that can serve thousands if not millions of users.</p><p>We&rsquo;ll continue to reference the content of this chapter as we move forward, as HTTP is one of the core web technologies along with HTML, CSS, and JavaScript.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis526/commit/41163dc548a00400a9f1d4962b4227b9a8ee4d20>Aug 10, 2023</a></p></div></div><script src=/cis526/js/clipboard.min.js?1738617099 defer></script><script src=/cis526/js/perfect-scrollbar.min.js?1738617099 defer></script><script src=/cis526/js/theme.js?1738617099 defer></script></body></html>