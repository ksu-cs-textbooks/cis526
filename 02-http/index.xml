




	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hyper-Text Transfer Protocol on CIS 526 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis526/02-http/</link>
    <description>Recent content in Hyper-Text Transfer Protocol on CIS 526 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis526/02-http/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/01-introduction/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/01-introduction/</guid>
      <description>At the heart of the world wide web is the Hyper-Text Transfer Protocol (HTTP). This is a protocol defining how HTTP servers (which host web pages) interact with HTTP clients (which display web pages).
It starts with a request initiated from the web browser (the client). This request is sent over the Internet using the TCP protocol to a web server. Once the web server receives the request, it must decide the appropriate response - ideally sending the requested resource back to the browser to be displayed.</description>
    </item>
    <item>
      <title>Browser Requests</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/02-browser-requests/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/02-browser-requests/</guid>
      <description>Before we get too deep in the details of what a request is, and how it works, let&amp;rsquo;s explore the primary kind of request you&amp;rsquo;re already used to making - requests originating from a browser. Every time you use a browser to browse the Internet, you are creating a series of HTTP (or HTTPS) requests that travel across the networks between you and a web server, which responds to your requests.</description>
    </item>
    <item>
      <title>Request Format</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/03-request-format/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/03-request-format/</guid>
      <description>So now that we&amp;rsquo;ve seen HTTP Requests in action, let&amp;rsquo;s examine what they are. A HTTP Request is just a stream text that follows a specific format and sent from a client to a server.
It consists of one or more lines terminated by a CRLF (a carriage return and a line feed character, typically written \r\n in most programming languages).
A request-line describing the request Additional optional lines containing HTTP headers.</description>
    </item>
    <item>
      <title>Request Methods</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/04-request-methods/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/04-request-methods/</guid>
      <description>The first line of the HTTP request includes the request method, which indicates what kind of action the request is making of the web server (these methods are also known as HTTP Verbs). The two most common are GET and POST, as these are supported by most browsers.
Commonly HTTP Methods The following requests are those most commonly used in web development. As noted before GET and POST requests are the most commonly used by web browsers, while GET, PUT, PATCH, and DELETE are used by RESTful APIs.</description>
    </item>
    <item>
      <title>URIs and URLs</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/05-uris-and-urls/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/05-uris-and-urls/</guid>
      <description>Before a web request can be made, the browser needs to know where the resource requested can be found. This is the role that a Universal Resource Locator (a URL) plays. A URL is a specific kind of Universal Resource Indicator (URI) that specifies how a specific resource can be retrieved.
Info URLs and URIs The terms URL and URI are often used interchangeably in practice. However, a URL is a specific subset of URIs that indicate how to retrieve a resource over a network; while a URI identifies a unique resource, it does not necessarily indicate how to retrieve it.</description>
    </item>
    <item>
      <title>Request Headers</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/06-request-headers/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/06-request-headers/</guid>
      <description>Request headers take the form of key-value pairs, separated by colons : and terminated with a CRLF (a carriage return and line feed character). For example:
Accept-Encoding: gzip Indicates that the browser knows how to accepted content compressed in the Gzip format.
Note that request headers are a subset of message headers that apply specifically to requests. There are also message headers that apply only to HTTP responses, and some that apply to both.</description>
    </item>
    <item>
      <title>Request Body</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/07-request-body/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/07-request-body/</guid>
      <description>After the request headers and an extra CRLF (carriage return and line feed) is the request body.
For GET and DELETE requests, there is no body. For POST, PUT, and PATCH, however, this section should contain the data being sent to the server. If there is a body, the headers should include Content-Type and Content-Length. The Content-Length is always provided as a count of octets (a set of eight bits). Thus, binary data is sent as an octet stream.</description>
    </item>
    <item>
      <title>Response Format</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/08-response-format/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/08-response-format/</guid>
      <description>Similar to an HTTP Request, an HTTP response is typically a stream of text and possibly data:
It consists of one or more lines of text, terminated by a CRLF (sequential carriage return and line feed characters):
A status-line indicating the HTTP protocol, the status code, and a textual status Optional lines containing the Response Headers. These specify the details of the response or describe the response body A blank line, indicating the end of the response metadata An optional response body.</description>
    </item>
    <item>
      <title>Status Codes</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/09-status-codes/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/09-status-codes/</guid>
      <description>The status-line consists of a numeric code, followed by a space, and then a human-readable status message that goes with the code. The codes themselves are 3-digit numbers, with the first number indicating a general category the response status falls into. Essentially, the status code indicates that the request is being fulfilled, or the reason it cannot be.
1XX Status Codes Codes falling in the 100&amp;rsquo;s provide some kind of information, often in response to a HEAD or upgrade request.</description>
    </item>
    <item>
      <title>Response Headers</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/10-response-headers/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/10-response-headers/</guid>
      <description>Response headers take the form of key-value pairs, separated by colons : and terminated with a CRLF (a carriage return and line feed character), just like Request Headers (both are types of Message Headers). For example, this header:
Expires: Wed, 12 Jun 2019 08:00:00 CST indicates to the browser that this content will expire June 12, 2019 at 8AM Central Standard Time. The browser can use this value when populating its cache, allowing it to use the cached version until the expiration time, reducing the need to make requests.</description>
    </item>
    <item>
      <title>Response Body</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/11-response-body/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/11-response-body/</guid>
      <description>After the response headers and an extra CRLF (carriage return and line feed) is the response body.
The body is typically text (for HTML, CSS, JavaScript, and other text files) or binary data (for images, video, and other file types).
Setting the Content-Type and Content-Length headers lets the web client know what kind of data, and how much of it, should be expected. If these headers are not supplied in the response, the browser may treat the body as a blob of binary data, and only offer to save it.</description>
    </item>
    <item>
      <title>HTTP 2.0</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/12-http-2-0/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/12-http-2-0/</guid>
      <description>You may have noticed that the earlier parts of this chapter focused on HTTP version 1.1, while mentioning version 2.0. You might wonder why we didn&amp;rsquo;t instead look at version 2.0 - and it&amp;rsquo;s a valid question.
In short, HTTP 2.0 was created to make the request-response pattern of the web more efficient. One method it uses to do so is switching from text-based representations of requests and responses to binary-based representations.</description>
    </item>
    <item>
      <title>Statelessness and Scaling</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/13-statelessness-and-scaling/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/13-statelessness-and-scaling/</guid>
      <description>One final point to make about Hyper-Text Transfer Protocol. It is a stateless protocol. What this means is that the server does not need to keep track of previous requests - each request is treated as though it was the first time a request has been made.
This approach is important for several reasons. One, if a server must keep track of previous requests, the amount of memory required would grow quickly, especially for popular web sites.</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cis526/02-http/14-summary/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis526/02-http/14-summary/</guid>
      <description>In this chapter, we explored the Hyper-Text Transfer Protocol (HTTP), the technology used to exchange data across the web. We saw how requests and responses are simply well-structured streams of text or data exchanged across a packet-switched network. We examined the structure of these requests, and saw how they all use a similar pattern of a request or response line, a series of headers carrying metadata about the request or response, and an optional body.</description>
    </item>
  </channel>
</rss>